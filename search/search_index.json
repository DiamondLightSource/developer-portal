{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The documentation is split into two sections: The User Guide contains documentation on how to use the developer portal. This is split into four sub-sections: Tutorials provide worked examples for typical usage. New users should start here. How-Tos provide step-by-step guides for more experienced users. Explanations provide insight into how the service works and why it works that way. References provide technical reference material including APIs and release notes. The Developer Guide contains documentation on how to develop and contribute changes back to the developer portal. This is split into four sub-sections: Tutorials provide worked examples of some relevent tasks. How-Tos provide step-by-step guides for day-to-day tasks. Explanations provide insight into how and why the architecture is the way it is. References provide technical reference material on the standards in use.","title":"Home"},{"location":"developer/","text":"Developer Guide Home \u00b6 The Developer Guide contains documentation on how to develop and contribute changes back to the developer portal. This is split into four sub-sections: Tutorials provide worked examples of some relevent tasks. How-Tos provide step-by-step guides for day-to-day tasks. Explanations provide insight into how and why the architecture is the way it is. References provide technical reference material on the standards in use.","title":"Home"},{"location":"developer/#developer-guide-home","text":"The Developer Guide contains documentation on how to develop and contribute changes back to the developer portal. This is split into four sub-sections: Tutorials provide worked examples of some relevent tasks. How-Tos provide step-by-step guides for day-to-day tasks. Explanations provide insight into how and why the architecture is the way it is. References provide technical reference material on the standards in use.","title":"Developer Guide Home"},{"location":"developer/explanations/","text":"Developer Explanations \u00b6 {nav}","title":"Home"},{"location":"developer/explanations/#developer-explanations","text":"{nav}","title":"Developer Explanations"},{"location":"developer/how-tos/","text":"Developer How Tos \u00b6 {nav}","title":"Home"},{"location":"developer/how-tos/#developer-how-tos","text":"{nav}","title":"Developer How Tos"},{"location":"developer/references/","text":"Developer References \u00b6 {nav}","title":"Home"},{"location":"developer/references/#developer-references","text":"{nav}","title":"Developer References"},{"location":"developer/tutorials/","text":"Developer Tutorials \u00b6 {nav}","title":"Home"},{"location":"developer/tutorials/#developer-tutorials","text":"{nav}","title":"Developer Tutorials"},{"location":"user/","text":"User Guide Home \u00b6 The User Guide contains documentation on how to use the developer portal. This is split into four sub-sections: Tutorials provide worked examples for typical usage. New users should start here. How-Tos provide step-by-step guides for more experienced users. Explanations provide insight into how the service works and why it works that way. References provide technical reference material including APIs and release notes.","title":"Home"},{"location":"user/#user-guide-home","text":"The User Guide contains documentation on how to use the developer portal. This is split into four sub-sections: Tutorials provide worked examples for typical usage. New users should start here. How-Tos provide step-by-step guides for more experienced users. Explanations provide insight into how the service works and why it works that way. References provide technical reference material including APIs and release notes.","title":"User Guide Home"},{"location":"user/explanations/","text":"User Explanations \u00b6 {nav}","title":"Home"},{"location":"user/explanations/#user-explanations","text":"{nav}","title":"User Explanations"},{"location":"user/explanations/entity-ingress/","text":"Entity Ingress \u00b6 The diamond developer portal is configured such that entity ingress must be performed via discovery, allowing it to act as a transparent window onto the software and services currently developed and deployed at Diamond. As a consequence of this, for a entity to become available in the catalogue, an entity descriptor (commonly a catalog-info.yaml file) must be be made available in one of the discovery locations .","title":"Entity Ingress"},{"location":"user/explanations/entity-ingress/#entity-ingress","text":"The diamond developer portal is configured such that entity ingress must be performed via discovery, allowing it to act as a transparent window onto the software and services currently developed and deployed at Diamond. As a consequence of this, for a entity to become available in the catalogue, an entity descriptor (commonly a catalog-info.yaml file) must be be made available in one of the discovery locations .","title":"Entity Ingress"},{"location":"user/how-tos/","text":"User How Tos \u00b6 {nav}","title":"Home"},{"location":"user/how-tos/#user-how-tos","text":"{nav}","title":"User How Tos"},{"location":"user/how-tos/register-a-component/","text":"Register a Component \u00b6 Preface \u00b6 This how-to will take you through the steps of registering a Component with the developer portal. It is assumed that this Component already exists and is commited to version control in one of the discovery locations . As detailed in the entity ingress explanation , the developer portal is configured to automatically pick up entity descriptors present in the discovery locations . Thus registering a Component is as simple as adding an entity descriptor to your repository. Whilst a minimal entity descriptor will suffice in getting the Component on the portal, adding relations is highly encouraged as they massively help facilitate understanding of complex systems. Create an Entity Descriptor \u00b6 Entity Descriptor Format For a exhaustive description of the entity descriptor format, see the backstage docs . Firstly, we must create the entity descriptor file, catalog-info.yaml , at the root of the repository. To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Component . E.g.: 1 2 apiVersion : backstage.io/v1alpha1 kind : Component Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. The metadata must include a name and may optionally include several others, we will choose to give it a title and a description . The name must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] , whilst the title should be short human readable name and the description a longer human readable description of the Component . E.g.: 1 2 3 4 metadata : name : developer-portal-backend title : Developer Portal Backend description : A node application performing discovery and providing the developer portal REST API. Component Spec \u00b6 Finally, we will fill out the Component spec . For this only the type is required but again we may optionally include several others, we will choose to give it a lifecycle and an owner . Whilst type may be any string, it is best to use one of the common component types ; similarly lifecycle may be any string, it is best to use one of the common lifecycle stages ; the owner should reference either a group or a user already available on the catalog the with the syntax of group:<groupName> or user:<fedId> respectively. E.g.: 1 2 3 4 spec : type : service lifecycle : experimental owner : user:enu43627 Relations \u00b6 To futher aid with the understanding of software systems, it is valuable to record relations between entities in the catalog. For a Component , this can be done by adding the following records under the spec : system - a reference to the System which this Component is part of providesApis - a reference to an API which this Component provides consumesApis - a reference to an API which this Component consumes dependsOn - a reference to another Comoponent , typically of type: Library , which this Component depends on E.g.: 1 2 3 4 dependsOn : - component:developer-guide providesApis : - developer-portal-backend-rest Completed Descriptor Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-backend title : Developer Portal Backend description : A node application performing discovery and providing the developer portal REST API. spec : type : website lifecycle : experimental system : developer-portal owner : user:enu43627 dependsOn : - component:developer-guide providesApis : - developer-portal-backend-rest Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Register a Component"},{"location":"user/how-tos/register-a-component/#register-a-component","text":"","title":"Register a Component"},{"location":"user/how-tos/register-a-component/#preface","text":"This how-to will take you through the steps of registering a Component with the developer portal. It is assumed that this Component already exists and is commited to version control in one of the discovery locations . As detailed in the entity ingress explanation , the developer portal is configured to automatically pick up entity descriptors present in the discovery locations . Thus registering a Component is as simple as adding an entity descriptor to your repository. Whilst a minimal entity descriptor will suffice in getting the Component on the portal, adding relations is highly encouraged as they massively help facilitate understanding of complex systems.","title":"Preface"},{"location":"user/how-tos/register-a-component/#create-an-entity-descriptor","text":"Entity Descriptor Format For a exhaustive description of the entity descriptor format, see the backstage docs . Firstly, we must create the entity descriptor file, catalog-info.yaml , at the root of the repository. To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Component . E.g.: 1 2 apiVersion : backstage.io/v1alpha1 kind : Component","title":"Create an Entity Descriptor"},{"location":"user/how-tos/register-a-component/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. The metadata must include a name and may optionally include several others, we will choose to give it a title and a description . The name must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] , whilst the title should be short human readable name and the description a longer human readable description of the Component . E.g.: 1 2 3 4 metadata : name : developer-portal-backend title : Developer Portal Backend description : A node application performing discovery and providing the developer portal REST API.","title":"Metadata"},{"location":"user/how-tos/register-a-component/#component-spec","text":"Finally, we will fill out the Component spec . For this only the type is required but again we may optionally include several others, we will choose to give it a lifecycle and an owner . Whilst type may be any string, it is best to use one of the common component types ; similarly lifecycle may be any string, it is best to use one of the common lifecycle stages ; the owner should reference either a group or a user already available on the catalog the with the syntax of group:<groupName> or user:<fedId> respectively. E.g.: 1 2 3 4 spec : type : service lifecycle : experimental owner : user:enu43627","title":"Component Spec"},{"location":"user/how-tos/register-a-component/#relations","text":"To futher aid with the understanding of software systems, it is valuable to record relations between entities in the catalog. For a Component , this can be done by adding the following records under the spec : system - a reference to the System which this Component is part of providesApis - a reference to an API which this Component provides consumesApis - a reference to an API which this Component consumes dependsOn - a reference to another Comoponent , typically of type: Library , which this Component depends on E.g.: 1 2 3 4 dependsOn : - component:developer-guide providesApis : - developer-portal-backend-rest Completed Descriptor Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-backend title : Developer Portal Backend description : A node application performing discovery and providing the developer portal REST API. spec : type : website lifecycle : experimental system : developer-portal owner : user:enu43627 dependsOn : - component:developer-guide providesApis : - developer-portal-backend-rest","title":"Relations"},{"location":"user/how-tos/register-a-component/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"user/how-tos/register-a-static-api/","text":"Register a Static API \u00b6 Preface \u00b6 This how-to will take you through the steps of registering a static API with the developer portal. It is assumed that this API already exists and a static schema can be commited to version control in one of the discovery locations . As detailed in the entity ingress explanation , the developer portal is configured to automatically pick up entity descriptors present in the discovery locations . Thus registering an API is as simple as adding an entity descriptor to your repository. Whilst a minimal entity descriptor will suffice in getting the API on the portal, adding relations is highly encouraged as they massively help facilitate understanding of complex systems. Create an Entity Descriptor \u00b6 Entity Descriptor Format For a exhaustive description of the entity descriptor format, see the backstage docs . Firstly, we must create the entity descriptor file, catalog-info.yaml , at the root of the repository. To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as API . E.g.: 1 2 apiVersion : backstage.io/v1alpha1 kind : API Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. The metadata must include a name and may optionally include several others, we will choose to give it a title and a description . The name must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] , whilst the title should be short human readable name and the description a longer human readable description of the API . E.g.: 1 2 3 4 metadata : name : developer-portal-backend-rest title : Developer Portal Backend REST API description : A RESTful API exposed by the developer portal backend. API Spec \u00b6 Finally, we will fill out the API spec . For this a type , lifecycle , owner and definition are required but again we may optionally include several others. Whilst type may be any string, it is best to use one of the common API types ; similarly lifecycle may be any string, it is best to use one of the common lifecycle stages ; the owner should reference either a group or a user already available on the catalog the with the syntax of group:<groupName> or user:<fedId> respectively. The definiton is used to describe the API itself and should be assigned a multi-line string appropriate for it's type (e.g. an openapi schema string for an API of type: openapi ). E.g.: 1 2 3 4 5 6 7 8 9 spec : type : service lifecycle : experimental owner : user:enu43627 definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Schema Generation It is often possible to generate API schemas with tools provided by server libraries or frameworks. Here's how to do so for some common API server libraries: FastAPI Completed Descriptor Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 apiVersion : backstage.io/v1alpha1 kind : API metadata : name : developer-portal-backend-rest description : A RESTful API exposed by the developer portal backend. spec : type : openapi lifecycle : experimental owner : user:enu43627 system : developer-portal definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Register a Static API"},{"location":"user/how-tos/register-a-static-api/#register-a-static-api","text":"","title":"Register a Static API"},{"location":"user/how-tos/register-a-static-api/#preface","text":"This how-to will take you through the steps of registering a static API with the developer portal. It is assumed that this API already exists and a static schema can be commited to version control in one of the discovery locations . As detailed in the entity ingress explanation , the developer portal is configured to automatically pick up entity descriptors present in the discovery locations . Thus registering an API is as simple as adding an entity descriptor to your repository. Whilst a minimal entity descriptor will suffice in getting the API on the portal, adding relations is highly encouraged as they massively help facilitate understanding of complex systems.","title":"Preface"},{"location":"user/how-tos/register-a-static-api/#create-an-entity-descriptor","text":"Entity Descriptor Format For a exhaustive description of the entity descriptor format, see the backstage docs . Firstly, we must create the entity descriptor file, catalog-info.yaml , at the root of the repository. To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as API . E.g.: 1 2 apiVersion : backstage.io/v1alpha1 kind : API","title":"Create an Entity Descriptor"},{"location":"user/how-tos/register-a-static-api/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. The metadata must include a name and may optionally include several others, we will choose to give it a title and a description . The name must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] , whilst the title should be short human readable name and the description a longer human readable description of the API . E.g.: 1 2 3 4 metadata : name : developer-portal-backend-rest title : Developer Portal Backend REST API description : A RESTful API exposed by the developer portal backend.","title":"Metadata"},{"location":"user/how-tos/register-a-static-api/#api-spec","text":"Finally, we will fill out the API spec . For this a type , lifecycle , owner and definition are required but again we may optionally include several others. Whilst type may be any string, it is best to use one of the common API types ; similarly lifecycle may be any string, it is best to use one of the common lifecycle stages ; the owner should reference either a group or a user already available on the catalog the with the syntax of group:<groupName> or user:<fedId> respectively. The definiton is used to describe the API itself and should be assigned a multi-line string appropriate for it's type (e.g. an openapi schema string for an API of type: openapi ). E.g.: 1 2 3 4 5 6 7 8 9 spec : type : service lifecycle : experimental owner : user:enu43627 definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Schema Generation It is often possible to generate API schemas with tools provided by server libraries or frameworks. Here's how to do so for some common API server libraries: FastAPI Completed Descriptor Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 apiVersion : backstage.io/v1alpha1 kind : API metadata : name : developer-portal-backend-rest description : A RESTful API exposed by the developer portal backend. spec : type : openapi lifecycle : experimental owner : user:enu43627 system : developer-portal definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1","title":"API Spec"},{"location":"user/how-tos/register-a-static-api/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"user/how-tos/register-multiple-entities/","text":"Register Mutliple Entities \u00b6 Preface \u00b6 This how-to will take you through the steps of registering multiple entities in the catalogue from a single repository. It is assumed that these entities already exist and are commited to version control in one of the discovery locations . As detailed in the entity ingress explanation , the developer portal is configured to automatically pick up entity descriptors present in the discovery locations . Unfortunately this discovery is limited to a single entity per repository, which must be located at it's search location. In order to register multiple entities we will create a Location entity which in turn will link to the other entities we wish to register. Create Entity Descriptors \u00b6 We will begin by creating a number of entity descriptor files, as explained in Register a Component or Register a Static API , these files should be given names and located in directories appropriate to the entity they register. E.g. the my-component Component entity descriptor may be located at my-component/catalog-info.yaml or catalog-info/my-component.yaml . Create a Location Entity \u00b6 Entity Descriptor Format For a exhaustive description of the entity descriptor format, see the backstage docs . To link together these entitiy descriptors we will use a Location entity descriptor, these are used to point the discovery process to other entity descriptors, typically by URL . Firstly, we must create the entity descriptor file, catalog-info.yaml, at the root of the repository. To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Location . E.g.: 1 2 apiVersion : backstage.io/v1alpha1 kind : Location Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. The metadata must include a name and may optionally include several others, we will choose to give it a title and a description . The name must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] , whilst the title should be short human readable name and the description a longer human readable description of the API . E.g.: 1 2 3 4 metadata : name : developer-portal title : Developer Portal description : The diamond developer portal. Location Spec \u00b6 Finally, we will fill out the Location spec . For this a type and targets are required but again we may optionally include several others. The type field must be either url or file , however as file refers to a local file only url is useful; The targets entry should consist a list of url s directing the discovery task to other entity descriptors. E.g.: 1 2 3 4 5 6 7 spec : type : url targets : - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/system.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/frontend.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/backend.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/backend-rest.yaml Completed Descriptor Example 1 2 3 4 5 6 7 8 9 10 11 12 apiVersion : backstage.io/v1alpha1 kind : Location metadata : name : developer-portal description : A RESTful API exposed by the developer portal backend. spec : type : url targets : - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/system.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/frontend.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/backend.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/backend-rest.yaml Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Register Mutliple Entities"},{"location":"user/how-tos/register-multiple-entities/#register-mutliple-entities","text":"","title":"Register Mutliple Entities"},{"location":"user/how-tos/register-multiple-entities/#preface","text":"This how-to will take you through the steps of registering multiple entities in the catalogue from a single repository. It is assumed that these entities already exist and are commited to version control in one of the discovery locations . As detailed in the entity ingress explanation , the developer portal is configured to automatically pick up entity descriptors present in the discovery locations . Unfortunately this discovery is limited to a single entity per repository, which must be located at it's search location. In order to register multiple entities we will create a Location entity which in turn will link to the other entities we wish to register.","title":"Preface"},{"location":"user/how-tos/register-multiple-entities/#create-entity-descriptors","text":"We will begin by creating a number of entity descriptor files, as explained in Register a Component or Register a Static API , these files should be given names and located in directories appropriate to the entity they register. E.g. the my-component Component entity descriptor may be located at my-component/catalog-info.yaml or catalog-info/my-component.yaml .","title":"Create Entity Descriptors"},{"location":"user/how-tos/register-multiple-entities/#create-a-location-entity","text":"Entity Descriptor Format For a exhaustive description of the entity descriptor format, see the backstage docs . To link together these entitiy descriptors we will use a Location entity descriptor, these are used to point the discovery process to other entity descriptors, typically by URL . Firstly, we must create the entity descriptor file, catalog-info.yaml, at the root of the repository. To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Location . E.g.: 1 2 apiVersion : backstage.io/v1alpha1 kind : Location","title":"Create a Location Entity"},{"location":"user/how-tos/register-multiple-entities/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. The metadata must include a name and may optionally include several others, we will choose to give it a title and a description . The name must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] , whilst the title should be short human readable name and the description a longer human readable description of the API . E.g.: 1 2 3 4 metadata : name : developer-portal title : Developer Portal description : The diamond developer portal.","title":"Metadata"},{"location":"user/how-tos/register-multiple-entities/#location-spec","text":"Finally, we will fill out the Location spec . For this a type and targets are required but again we may optionally include several others. The type field must be either url or file , however as file refers to a local file only url is useful; The targets entry should consist a list of url s directing the discovery task to other entity descriptors. E.g.: 1 2 3 4 5 6 7 spec : type : url targets : - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/system.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/frontend.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/backend.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/backend-rest.yaml Completed Descriptor Example 1 2 3 4 5 6 7 8 9 10 11 12 apiVersion : backstage.io/v1alpha1 kind : Location metadata : name : developer-portal description : A RESTful API exposed by the developer portal backend. spec : type : url targets : - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/system.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/frontend.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/backend.yaml - https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info/backend-rest.yaml","title":"Location Spec"},{"location":"user/how-tos/register-multiple-entities/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"user/references/","text":"User References \u00b6 {nav}","title":"Home"},{"location":"user/references/#user-references","text":"{nav}","title":"User References"},{"location":"user/references/common-api-types/","text":"Common API Types \u00b6 Whilst the spec.type of a API may be any string, visualisation is only available for a small subset. Further to this, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an API one of the following is used in this field: openapi - an API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec asyncapi - an API definition based on the AsyncAPI spec graphql - an API definition based on GraphQL schemas for consuming GraphQL based APIs grpc - an API definition based on Protocol Buffers to use with gRPC These are selected such that they overlap with the common API types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common API Types"},{"location":"user/references/common-api-types/#common-api-types","text":"Whilst the spec.type of a API may be any string, visualisation is only available for a small subset. Further to this, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an API one of the following is used in this field: openapi - an API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec asyncapi - an API definition based on the AsyncAPI spec graphql - an API definition based on GraphQL schemas for consuming GraphQL based APIs grpc - an API definition based on Protocol Buffers to use with gRPC These are selected such that they overlap with the common API types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common API Types"},{"location":"user/references/common-component-types/","text":"Common Component Types \u00b6 Whilst the spec.type of a Component may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying a component one of the following is used in this field: service - a backend service, typically exposing an API website - a website library - a software library These are selected such that they overlap with the common component types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common Component Types"},{"location":"user/references/common-component-types/#common-component-types","text":"Whilst the spec.type of a Component may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying a component one of the following is used in this field: service - a backend service, typically exposing an API website - a website library - a software library These are selected such that they overlap with the common component types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common Component Types"},{"location":"user/references/common-lifecycle-stages/","text":"Common Lifecycle Stages \u00b6 Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying a component one of the following is used in this field: experimental - an experiment or early, non-production component, signaling that users may not prefer to consume it over other more established components, or that there are low or no reliability guarantees production - an established, owned, maintained component deprecated - a component that is at the end of its lifecycle, and may disappear at a later point in time These are selected such that they overlap with the common component types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common Lifecycle Stages"},{"location":"user/references/common-lifecycle-stages/#common-lifecycle-stages","text":"Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying a component one of the following is used in this field: experimental - an experiment or early, non-production component, signaling that users may not prefer to consume it over other more established components, or that there are low or no reliability guarantees production - an established, owned, maintained component deprecated - a component that is at the end of its lifecycle, and may disappear at a later point in time These are selected such that they overlap with the common component types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common Lifecycle Stages"},{"location":"user/references/discovery-locations/","text":"Discovery Locations \u00b6 The developer portal is configured to search a number of locations for entity descriptors (commonly a catalog-info.yaml file). These locations include, but are not limited to: github.com/DiamondLightSource (GIT) Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk (GIT) Entity descriptors at /catalog-info.yaml ralfed.cclrc.ac.uk (LDAP) Users For a full list of discovery locations, please check the catalog.providers section of the backstage configuration file backstage/app-config.yaml ( on main ).","title":"Discovery Locations"},{"location":"user/references/discovery-locations/#discovery-locations","text":"The developer portal is configured to search a number of locations for entity descriptors (commonly a catalog-info.yaml file). These locations include, but are not limited to: github.com/DiamondLightSource (GIT) Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk (GIT) Entity descriptors at /catalog-info.yaml ralfed.cclrc.ac.uk (LDAP) Users For a full list of discovery locations, please check the catalog.providers section of the backstage configuration file backstage/app-config.yaml ( on main ).","title":"Discovery Locations"},{"location":"user/tutorials/","text":"User Tutorials \u00b6 {nav}","title":"Home"},{"location":"user/tutorials/#user-tutorials","text":"{nav}","title":"User Tutorials"}]}