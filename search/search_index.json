{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Popular \u00b6 You may wish to start with one of these: Web App Registration Tutorial How To Register A Component How To Register An API How To Register A System Structure \u00b6 The User Guide contains documentation on how to use the developer portal. This is split into four sub-sections: Tutorials provide worked examples for typical usage. New users should start here. How Tos provide step-by-step guides for more experienced users. Explanations provide insight into how the service works and why it works that way. References provide technical reference material including APIs and release notes.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#popular","text":"You may wish to start with one of these: Web App Registration Tutorial How To Register A Component How To Register An API How To Register A System","title":"Popular"},{"location":"#structure","text":"The User Guide contains documentation on how to use the developer portal. This is split into four sub-sections: Tutorials provide worked examples for typical usage. New users should start here. How Tos provide step-by-step guides for more experienced users. Explanations provide insight into how the service works and why it works that way. References provide technical reference material including APIs and release notes.","title":"Structure"},{"location":"common/create-entity-descriptor/","text":"Create an Entity Descriptor \u00b6 Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository.","title":"Create an Entity Descriptor"},{"location":"common/create-entity-descriptor/#create-an-entity-descriptor","text":"Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository.","title":"Create an Entity Descriptor"},{"location":"common/create-entity-metadata/","text":"Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference .","title":"Metadata"},{"location":"common/create-entity-metadata/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference .","title":"Metadata"},{"location":"common/entity-dependson/","text":"An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog.","title":"Entity dependson"},{"location":"common/entity-envelope/","text":"apiVersion [Required] \u00b6 The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal. kind [Required] \u00b6 The kind is the high level entity type being described. The available kind s are enumerated in the entity types reference .","title":"Entity envelope"},{"location":"common/entity-envelope/#apiversion-required","text":"The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal.","title":"apiVersion [Required]"},{"location":"common/entity-envelope/#kind-required","text":"The kind is the high level entity type being described. The available kind s are enumerated in the entity types reference .","title":"kind [Required]"},{"location":"common/entity-owner/","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"Entity owner"},{"location":"common/entity-system/","text":"An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System .","title":"Entity system"},{"location":"common/get-repository/","text":"Get a Repository \u00b6 To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml","title":"Get a Repository"},{"location":"common/get-repository/#get-a-repository","text":"To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml","title":"Get a Repository"},{"location":"common/push-and-wait/","text":"Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push & Wait"},{"location":"common/push-and-wait/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"explanations/api/","text":"APIs \u00b6 Summary \u00b6 An API describes an interface that can be exposed by a component. The API can be defined in different formats, like OpenAPI , AsyncAPI , GraphQL , gRPC , or other formats. See common api types for an exhaustive list of supported formats. Definition \u00b6 Backstage Docs See the backstage docs for a full description of the API entity definition. As with all other entities, an API consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec . apiVersion [Required] \u00b6 The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal. kind [Required] \u00b6 The kind is the high level entity type being described. For an API this must be API , e.g. kind: API . Other available kind s are enumerated in the entity types reference . metadata [Required] \u00b6 A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure. name [Required] \u00b6 The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] title [Optional] \u00b6 A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title. description [Optional] \u00b6 A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere. labels [Optional] \u00b6 Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above. annotations [Optional] \u00b6 An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings. tags [Optional] \u00b6 A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total. links [Optional] \u00b6 A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are: url [Required] \u00b6 A url in a standard uri format, e.g. url: https://example.com/some/page title [Optioanl] \u00b6 A user friendly display name for the link, e.g. title: Example Website icon [Optional] \u00b6 A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved. spec [Required] \u00b6 The actual specification data that describes the entity. type [Required] \u00b6 The type of API as a string, e.g. type: openapi . Whilst the spec.type of a API may be any string, visualisation is only available for a small subset. Further to this, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an API one of the following is used in this field: openapi - an API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec asyncapi - an API definition based on the AsyncAPI spec graphql - an API definition based on GraphQL schemas for consuming GraphQL based APIs grpc - an API definition based on Protocol Buffers to use with gRPC lifecycle [Required] \u00b6 The lifecycle state of the API as a string, e.g. lifecycle: production . Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner. system [Optional] \u00b6 An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System . definition [Required] \u00b6 The definition of the API, as a multi-line string, based on the format defined by type . For example, where type is openapi : definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Tip The API schema can be located in another file and imported by using substitutions, e.g.: definition : $text : ./schema-file.json $text , $json & $yaml are available, for more details see the backstage docs","title":"APIs"},{"location":"explanations/api/#apis","text":"","title":"APIs"},{"location":"explanations/api/#summary","text":"An API describes an interface that can be exposed by a component. The API can be defined in different formats, like OpenAPI , AsyncAPI , GraphQL , gRPC , or other formats. See common api types for an exhaustive list of supported formats.","title":"Summary"},{"location":"explanations/api/#definition","text":"Backstage Docs See the backstage docs for a full description of the API entity definition. As with all other entities, an API consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec .","title":"Definition"},{"location":"explanations/api/#apiversion-required","text":"The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal.","title":"apiVersion [Required]"},{"location":"explanations/api/#kind-required","text":"The kind is the high level entity type being described. For an API this must be API , e.g. kind: API . Other available kind s are enumerated in the entity types reference .","title":"kind [Required]"},{"location":"explanations/api/#metadata-required","text":"A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure.","title":"metadata [Required]"},{"location":"explanations/api/#name-required","text":"The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.]","title":"name [Required]"},{"location":"explanations/api/#title-optional","text":"A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title.","title":"title [Optional]"},{"location":"explanations/api/#description-optional","text":"A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere.","title":"description [Optional]"},{"location":"explanations/api/#labels-optional","text":"Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above.","title":"labels [Optional]"},{"location":"explanations/api/#annotations-optional","text":"An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings.","title":"annotations [Optional]"},{"location":"explanations/api/#tags-optional","text":"A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total.","title":"tags [Optional]"},{"location":"explanations/api/#links-optional","text":"A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are:","title":"links [Optional]"},{"location":"explanations/api/#url-required","text":"A url in a standard uri format, e.g. url: https://example.com/some/page","title":"url [Required]"},{"location":"explanations/api/#title-optioanl","text":"A user friendly display name for the link, e.g. title: Example Website","title":"title [Optioanl]"},{"location":"explanations/api/#icon-optional","text":"A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved.","title":"icon [Optional]"},{"location":"explanations/api/#spec-required","text":"The actual specification data that describes the entity.","title":"spec [Required]"},{"location":"explanations/api/#type-required","text":"The type of API as a string, e.g. type: openapi . Whilst the spec.type of a API may be any string, visualisation is only available for a small subset. Further to this, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an API one of the following is used in this field: openapi - an API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec asyncapi - an API definition based on the AsyncAPI spec graphql - an API definition based on GraphQL schemas for consuming GraphQL based APIs grpc - an API definition based on Protocol Buffers to use with gRPC","title":"type [Required]"},{"location":"explanations/api/#lifecycle-required","text":"The lifecycle state of the API as a string, e.g. lifecycle: production . Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time","title":"lifecycle [Required]"},{"location":"explanations/api/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"explanations/api/#system-optional","text":"An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System .","title":"system [Optional]"},{"location":"explanations/api/#definition-required","text":"The definition of the API, as a multi-line string, based on the format defined by type . For example, where type is openapi : definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Tip The API schema can be located in another file and imported by using substitutions, e.g.: definition : $text : ./schema-file.json $text , $json & $yaml are available, for more details see the backstage docs","title":"definition [Required]"},{"location":"explanations/component/","text":"Components \u00b6 Summary \u00b6 A Component describes a software component. It is typically intimately linked to the source code that constitutes the component, and should be what a developer may regard a \"unit of software\", usually with a distinct deployable or linkable artifact. Definition \u00b6 Backstage Docs See the backstage docs for a full description of the Component entity definition. As with all other entities, a component consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec . apiVersion [Required] \u00b6 The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal. kind [Required] \u00b6 The kind is the high level entity type being described. For a software component this must be Component , e.g. kind: Component . Other available kind s are enumerated in the entity types reference . metadata [Required] \u00b6 A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure. name [Required] \u00b6 The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] title [Optional] \u00b6 A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title. description [Optional] \u00b6 A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere. labels [Optional] \u00b6 Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above. annotations [Optional] \u00b6 An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings. tags [Optional] \u00b6 A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total. links [Optional] \u00b6 A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are: url [Required] \u00b6 A url in a standard uri format, e.g. url: https://example.com/some/page title [Optioanl] \u00b6 A user friendly display name for the link, e.g. title: Example Website icon [Optional] \u00b6 A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved. spec [Required] \u00b6 The actual specification data that describes the entity. type [Required] \u00b6 The type of Component as a string, e.g. type: service . Whilst the type of a Component may be any string, it is strongly recommended that you use one of the common values. Futher to this, tools including Backstage itself may read this field and behave differently depending on its value. For example, a website type component may present tooling in the Backstage interface that is specific to just websites. Thus we recommend that when specifying a component one of the following is used in this field: library - a software library service - a backend service, typically exposing an API user-interface - a local user interface website - a web user interface lifecycle [Required] \u00b6 The lifecycle state of the Component as a string, e.g. lifecycle: production . Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner. system [Optional] \u00b6 An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System . subcomponentOf [Optional] \u00b6 An entity reference to another Component of which this Component is part of, e.g. subComponentOf: developer-portal-frontend . There is no requirement for this Component to be created within the same location; Existing Components can be listed in the catalog by filtering by Kind of Component . providesApis [Optional] \u00b6 An array of entity references to the APIs that are provided by the Component, e.g. providesApis: [developer-portal-backend-rest] . There is no requirement for these APIs to be created within the same location; Existing APIs can be listed in the catalog by filtering by Kind of API . consumesApis [Optional] \u00b6 An array of entity references to the APIs that are consumed by the Component, e.g. consumesApis: [developer-portal-backend-rest] . There is no requirement for these APIs to be created within the same location; Existing APIs can be listed in the catalog by filtering by Kind of API . dependsOn [Optional] \u00b6 An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog.","title":"Components"},{"location":"explanations/component/#components","text":"","title":"Components"},{"location":"explanations/component/#summary","text":"A Component describes a software component. It is typically intimately linked to the source code that constitutes the component, and should be what a developer may regard a \"unit of software\", usually with a distinct deployable or linkable artifact.","title":"Summary"},{"location":"explanations/component/#definition","text":"Backstage Docs See the backstage docs for a full description of the Component entity definition. As with all other entities, a component consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec .","title":"Definition"},{"location":"explanations/component/#apiversion-required","text":"The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal.","title":"apiVersion [Required]"},{"location":"explanations/component/#kind-required","text":"The kind is the high level entity type being described. For a software component this must be Component , e.g. kind: Component . Other available kind s are enumerated in the entity types reference .","title":"kind [Required]"},{"location":"explanations/component/#metadata-required","text":"A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure.","title":"metadata [Required]"},{"location":"explanations/component/#name-required","text":"The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.]","title":"name [Required]"},{"location":"explanations/component/#title-optional","text":"A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title.","title":"title [Optional]"},{"location":"explanations/component/#description-optional","text":"A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere.","title":"description [Optional]"},{"location":"explanations/component/#labels-optional","text":"Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above.","title":"labels [Optional]"},{"location":"explanations/component/#annotations-optional","text":"An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings.","title":"annotations [Optional]"},{"location":"explanations/component/#tags-optional","text":"A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total.","title":"tags [Optional]"},{"location":"explanations/component/#links-optional","text":"A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are:","title":"links [Optional]"},{"location":"explanations/component/#url-required","text":"A url in a standard uri format, e.g. url: https://example.com/some/page","title":"url [Required]"},{"location":"explanations/component/#title-optioanl","text":"A user friendly display name for the link, e.g. title: Example Website","title":"title [Optioanl]"},{"location":"explanations/component/#icon-optional","text":"A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved.","title":"icon [Optional]"},{"location":"explanations/component/#spec-required","text":"The actual specification data that describes the entity.","title":"spec [Required]"},{"location":"explanations/component/#type-required","text":"The type of Component as a string, e.g. type: service . Whilst the type of a Component may be any string, it is strongly recommended that you use one of the common values. Futher to this, tools including Backstage itself may read this field and behave differently depending on its value. For example, a website type component may present tooling in the Backstage interface that is specific to just websites. Thus we recommend that when specifying a component one of the following is used in this field: library - a software library service - a backend service, typically exposing an API user-interface - a local user interface website - a web user interface","title":"type [Required]"},{"location":"explanations/component/#lifecycle-required","text":"The lifecycle state of the Component as a string, e.g. lifecycle: production . Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time","title":"lifecycle [Required]"},{"location":"explanations/component/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"explanations/component/#system-optional","text":"An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System .","title":"system [Optional]"},{"location":"explanations/component/#subcomponentof-optional","text":"An entity reference to another Component of which this Component is part of, e.g. subComponentOf: developer-portal-frontend . There is no requirement for this Component to be created within the same location; Existing Components can be listed in the catalog by filtering by Kind of Component .","title":"subcomponentOf [Optional]"},{"location":"explanations/component/#providesapis-optional","text":"An array of entity references to the APIs that are provided by the Component, e.g. providesApis: [developer-portal-backend-rest] . There is no requirement for these APIs to be created within the same location; Existing APIs can be listed in the catalog by filtering by Kind of API .","title":"providesApis [Optional]"},{"location":"explanations/component/#consumesapis-optional","text":"An array of entity references to the APIs that are consumed by the Component, e.g. consumesApis: [developer-portal-backend-rest] . There is no requirement for these APIs to be created within the same location; Existing APIs can be listed in the catalog by filtering by Kind of API .","title":"consumesApis [Optional]"},{"location":"explanations/component/#dependson-optional","text":"An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog.","title":"dependsOn [Optional]"},{"location":"explanations/domain/","text":"Domains \u00b6 Summary \u00b6 A Domain groups a collection of systems that share terminology, domain models, business purpose, or documentation, i.e. form a bounded context. Definition \u00b6 Backstage Docs See the backstage docs for a full description of the Domain entity definition. As with all other entities, a system consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec . apiVersion [Required] \u00b6 The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal. kind [Required] \u00b6 The kind is the high level entity type being described. For a software domain this must be Domain , e.g. kind: Domain . Other available kind s are enumerated in the entity types reference . metadata [Required] \u00b6 A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure. name [Required] \u00b6 The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] title [Optional] \u00b6 A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title. description [Optional] \u00b6 A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere. labels [Optional] \u00b6 Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above. annotations [Optional] \u00b6 An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings. tags [Optional] \u00b6 A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total. links [Optional] \u00b6 A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are: url [Required] \u00b6 A url in a standard uri format, e.g. url: https://example.com/some/page title [Optioanl] \u00b6 A user friendly display name for the link, e.g. title: Example Website icon [Optional] \u00b6 A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved. spec [Required] \u00b6 The actual specification data that describes the entity. owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"Domains"},{"location":"explanations/domain/#domains","text":"","title":"Domains"},{"location":"explanations/domain/#summary","text":"A Domain groups a collection of systems that share terminology, domain models, business purpose, or documentation, i.e. form a bounded context.","title":"Summary"},{"location":"explanations/domain/#definition","text":"Backstage Docs See the backstage docs for a full description of the Domain entity definition. As with all other entities, a system consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec .","title":"Definition"},{"location":"explanations/domain/#apiversion-required","text":"The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal.","title":"apiVersion [Required]"},{"location":"explanations/domain/#kind-required","text":"The kind is the high level entity type being described. For a software domain this must be Domain , e.g. kind: Domain . Other available kind s are enumerated in the entity types reference .","title":"kind [Required]"},{"location":"explanations/domain/#metadata-required","text":"A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure.","title":"metadata [Required]"},{"location":"explanations/domain/#name-required","text":"The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.]","title":"name [Required]"},{"location":"explanations/domain/#title-optional","text":"A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title.","title":"title [Optional]"},{"location":"explanations/domain/#description-optional","text":"A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere.","title":"description [Optional]"},{"location":"explanations/domain/#labels-optional","text":"Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above.","title":"labels [Optional]"},{"location":"explanations/domain/#annotations-optional","text":"An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings.","title":"annotations [Optional]"},{"location":"explanations/domain/#tags-optional","text":"A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total.","title":"tags [Optional]"},{"location":"explanations/domain/#links-optional","text":"A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are:","title":"links [Optional]"},{"location":"explanations/domain/#url-required","text":"A url in a standard uri format, e.g. url: https://example.com/some/page","title":"url [Required]"},{"location":"explanations/domain/#title-optioanl","text":"A user friendly display name for the link, e.g. title: Example Website","title":"title [Optioanl]"},{"location":"explanations/domain/#icon-optional","text":"A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved.","title":"icon [Optional]"},{"location":"explanations/domain/#spec-required","text":"The actual specification data that describes the entity.","title":"spec [Required]"},{"location":"explanations/domain/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"explanations/entity-ingress/","text":"Entity Ingress \u00b6 The diamond developer portal is configured such that entity ingress must be performed via discovery, allowing it to act as a transparent window onto the software and services currently developed and deployed at Diamond. As a consequence of this, for a entity to become available in the catalogue, an entity descriptor (commonly a catalog-info.yaml file) must be be made available in one of the discovery locations . These locations include, by type: Git: github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml LDAP: ralfed.cclrc.ac.uk Users Miscellaneous: gitlab.diamond.ac.uk/sscc-docs/groups Groups","title":"Entity Ingress"},{"location":"explanations/entity-ingress/#entity-ingress","text":"The diamond developer portal is configured such that entity ingress must be performed via discovery, allowing it to act as a transparent window onto the software and services currently developed and deployed at Diamond. As a consequence of this, for a entity to become available in the catalogue, an entity descriptor (commonly a catalog-info.yaml file) must be be made available in one of the discovery locations . These locations include, by type: Git: github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml LDAP: ralfed.cclrc.ac.uk Users Miscellaneous: gitlab.diamond.ac.uk/sscc-docs/groups Groups","title":"Entity Ingress"},{"location":"explanations/group/","text":"Groups \u00b6 A group describes an organizational entity, such as for example a team, a business unit, or a loose collection of people in an interest group. Members of these groups are modeled in the catalog as kind User . Group entities should not be defined by developer portal users, instead they will be automatically ingressed from one of the entity ingress locations.","title":"Groups"},{"location":"explanations/group/#groups","text":"A group describes an organizational entity, such as for example a team, a business unit, or a loose collection of people in an interest group. Members of these groups are modeled in the catalog as kind User . Group entities should not be defined by developer portal users, instead they will be automatically ingressed from one of the entity ingress locations.","title":"Groups"},{"location":"explanations/location/","text":"Locations \u00b6 Summary \u00b6 A location is a marker that references other places to look for catalog data. These are often used to register multiple entities with the catalog from a single discovery location by performing redirection to adjacent entity descriptors. Definition \u00b6 Backstage Docs See the backstage docs for a full description of the Location entity definition. As with all other entities, a location consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec . apiVersion [Required] \u00b6 The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal. kind [Required] \u00b6 The kind is the high level entity type being described. For an entity location this must be Location , e.g. kind: Location . Other available kind s are enumerated in the entity types reference . metadata [Required] \u00b6 A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure. name [Required] \u00b6 The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] title [Optional] \u00b6 A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title. description [Optional] \u00b6 A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere. labels [Optional] \u00b6 Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above. annotations [Optional] \u00b6 An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings. tags [Optional] \u00b6 A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total. links [Optional] \u00b6 A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are: url [Required] \u00b6 A url in a standard uri format, e.g. url: https://example.com/some/page title [Optioanl] \u00b6 A user friendly display name for the link, e.g. title: Example Website icon [Optional] \u00b6 A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved. spec [Required] \u00b6 The actual specification data that describes the entity. type [Optional] \u00b6 The single location type, that's common to the targets specified in the spec. Typically, this should be left empty such that the location type of the target is inherited from the location type of the location entity which defines it (i.e. your defined location). Other options include url - which instructs the catalog to retrieve the descriptor from the URL; or file - which instructs the catalog to retrieve the descriptor from a local file. targets [Optional] \u00b6 A list of targets as strings. They can all be either absolute paths/URLs (depending on the type), or relative paths which are resolved relative to the location of this Location entity itself. e.g.: targets : - ./frontend/component-info.yaml - ./backend/component-info.yaml - ./backend/api-info.yaml presence [Optional] \u00b6 Describes whether the target of a location is required to exist or not. It defaults to required if not specified, can also be optional .","title":"Locations"},{"location":"explanations/location/#locations","text":"","title":"Locations"},{"location":"explanations/location/#summary","text":"A location is a marker that references other places to look for catalog data. These are often used to register multiple entities with the catalog from a single discovery location by performing redirection to adjacent entity descriptors.","title":"Summary"},{"location":"explanations/location/#definition","text":"Backstage Docs See the backstage docs for a full description of the Location entity definition. As with all other entities, a location consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec .","title":"Definition"},{"location":"explanations/location/#apiversion-required","text":"The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal.","title":"apiVersion [Required]"},{"location":"explanations/location/#kind-required","text":"The kind is the high level entity type being described. For an entity location this must be Location , e.g. kind: Location . Other available kind s are enumerated in the entity types reference .","title":"kind [Required]"},{"location":"explanations/location/#metadata-required","text":"A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure.","title":"metadata [Required]"},{"location":"explanations/location/#name-required","text":"The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.]","title":"name [Required]"},{"location":"explanations/location/#title-optional","text":"A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title.","title":"title [Optional]"},{"location":"explanations/location/#description-optional","text":"A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere.","title":"description [Optional]"},{"location":"explanations/location/#labels-optional","text":"Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above.","title":"labels [Optional]"},{"location":"explanations/location/#annotations-optional","text":"An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings.","title":"annotations [Optional]"},{"location":"explanations/location/#tags-optional","text":"A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total.","title":"tags [Optional]"},{"location":"explanations/location/#links-optional","text":"A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are:","title":"links [Optional]"},{"location":"explanations/location/#url-required","text":"A url in a standard uri format, e.g. url: https://example.com/some/page","title":"url [Required]"},{"location":"explanations/location/#title-optioanl","text":"A user friendly display name for the link, e.g. title: Example Website","title":"title [Optioanl]"},{"location":"explanations/location/#icon-optional","text":"A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved.","title":"icon [Optional]"},{"location":"explanations/location/#spec-required","text":"The actual specification data that describes the entity.","title":"spec [Required]"},{"location":"explanations/location/#type-optional","text":"The single location type, that's common to the targets specified in the spec. Typically, this should be left empty such that the location type of the target is inherited from the location type of the location entity which defines it (i.e. your defined location). Other options include url - which instructs the catalog to retrieve the descriptor from the URL; or file - which instructs the catalog to retrieve the descriptor from a local file.","title":"type [Optional]"},{"location":"explanations/location/#targets-optional","text":"A list of targets as strings. They can all be either absolute paths/URLs (depending on the type), or relative paths which are resolved relative to the location of this Location entity itself. e.g.: targets : - ./frontend/component-info.yaml - ./backend/component-info.yaml - ./backend/api-info.yaml","title":"targets [Optional]"},{"location":"explanations/location/#presence-optional","text":"Describes whether the target of a location is required to exist or not. It defaults to required if not specified, can also be optional .","title":"presence [Optional]"},{"location":"explanations/resource/","text":"Resources \u00b6 Summary \u00b6 A resource describes the infrastructure a System needs to operate, like BigTable databases, Pub/Sub topics, S3 buckets or CDNs. Modelling them together with components and systems allows to visualize resource footprint, and create tooling around them. Definitions \u00b6 Backstage Docs See the backstage docs for a full description of the Resource entity definition. As with all other entities, a resource consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec . apiVersion [Required] \u00b6 The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal. kind [Required] \u00b6 The kind is the high level entity type being described. For a resource this must be Resource , e.g. kind: Resource . Other available kind s are enumerated in the entity types reference . metadata [Required] \u00b6 A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure. name [Required] \u00b6 The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] title [Optional] \u00b6 A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title. description [Optional] \u00b6 A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere. labels [Optional] \u00b6 Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above. annotations [Optional] \u00b6 An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings. tags [Optional] \u00b6 A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total. links [Optional] \u00b6 A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are: url [Required] \u00b6 A url in a standard uri format, e.g. url: https://example.com/some/page title [Optioanl] \u00b6 A user friendly display name for the link, e.g. title: Example Website icon [Optional] \u00b6 A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved. spec [Required] \u00b6 The actual specification data that describes the entity. owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner. type [Required] \u00b6 The type of resource as a string, e.g. database. There is currently no enforced set of values for this field, so it is left up to the user to decide an appropriate name, in doing so the user is encouraged to reference existing Resources on the developer portal. Some common values for this field may include: database s3-bucket cluster system [Optional] \u00b6 An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System . dependsOn [Optional] \u00b6 An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog. dependencyOf [Optional] \u00b6 An array of entity references to the Components and Resources that this resource is a dependency of, e.g. dependencyOf: [artist-lookup] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog. Use of this field is discouraged in favour defining dependsOn on the dependant Component or Resource.","title":"Resources"},{"location":"explanations/resource/#resources","text":"","title":"Resources"},{"location":"explanations/resource/#summary","text":"A resource describes the infrastructure a System needs to operate, like BigTable databases, Pub/Sub topics, S3 buckets or CDNs. Modelling them together with components and systems allows to visualize resource footprint, and create tooling around them.","title":"Summary"},{"location":"explanations/resource/#definitions","text":"Backstage Docs See the backstage docs for a full description of the Resource entity definition. As with all other entities, a resource consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec .","title":"Definitions"},{"location":"explanations/resource/#apiversion-required","text":"The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal.","title":"apiVersion [Required]"},{"location":"explanations/resource/#kind-required","text":"The kind is the high level entity type being described. For a resource this must be Resource , e.g. kind: Resource . Other available kind s are enumerated in the entity types reference .","title":"kind [Required]"},{"location":"explanations/resource/#metadata-required","text":"A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure.","title":"metadata [Required]"},{"location":"explanations/resource/#name-required","text":"The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.]","title":"name [Required]"},{"location":"explanations/resource/#title-optional","text":"A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title.","title":"title [Optional]"},{"location":"explanations/resource/#description-optional","text":"A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere.","title":"description [Optional]"},{"location":"explanations/resource/#labels-optional","text":"Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above.","title":"labels [Optional]"},{"location":"explanations/resource/#annotations-optional","text":"An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings.","title":"annotations [Optional]"},{"location":"explanations/resource/#tags-optional","text":"A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total.","title":"tags [Optional]"},{"location":"explanations/resource/#links-optional","text":"A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are:","title":"links [Optional]"},{"location":"explanations/resource/#url-required","text":"A url in a standard uri format, e.g. url: https://example.com/some/page","title":"url [Required]"},{"location":"explanations/resource/#title-optioanl","text":"A user friendly display name for the link, e.g. title: Example Website","title":"title [Optioanl]"},{"location":"explanations/resource/#icon-optional","text":"A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved.","title":"icon [Optional]"},{"location":"explanations/resource/#spec-required","text":"The actual specification data that describes the entity.","title":"spec [Required]"},{"location":"explanations/resource/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"explanations/resource/#type-required","text":"The type of resource as a string, e.g. database. There is currently no enforced set of values for this field, so it is left up to the user to decide an appropriate name, in doing so the user is encouraged to reference existing Resources on the developer portal. Some common values for this field may include: database s3-bucket cluster","title":"type [Required]"},{"location":"explanations/resource/#system-optional","text":"An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System .","title":"system [Optional]"},{"location":"explanations/resource/#dependson-optional","text":"An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog.","title":"dependsOn [Optional]"},{"location":"explanations/resource/#dependencyof-optional","text":"An array of entity references to the Components and Resources that this resource is a dependency of, e.g. dependencyOf: [artist-lookup] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog. Use of this field is discouraged in favour defining dependsOn on the dependant Component or Resource.","title":"dependencyOf [Optional]"},{"location":"explanations/system/","text":"Systems \u00b6 Summary \u00b6 A system is a collection of resources and components . The system may expose or consume one or several APIs . It is viewed as abstraction level that provides potential consumers insights into exposed features without needing a too detailed view into the details of all components. This also gives the owning team the possibility to decide about published artifacts and APIs. Definition \u00b6 Backstage Docs See the backstage docs for a full description of the System entity definition. As with all other entities, a system consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec . apiVersion [Required] \u00b6 The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal. kind [Required] \u00b6 The kind is the high level entity type being described. For a software system this must be System , e.g. kind: System . Other available kind s are enumerated in the entity types reference . metadata [Required] \u00b6 A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure. name [Required] \u00b6 The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] title [Optional] \u00b6 A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title. description [Optional] \u00b6 A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere. labels [Optional] \u00b6 Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above. annotations [Optional] \u00b6 An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings. tags [Optional] \u00b6 A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total. links [Optional] \u00b6 A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are: url [Required] \u00b6 A url in a standard uri format, e.g. url: https://example.com/some/page title [Optioanl] \u00b6 A user friendly display name for the link, e.g. title: Example Website icon [Optional] \u00b6 A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved. spec [Required] \u00b6 The actual specification data that describes the entity. owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner. domain [Optional] \u00b6 An entity reference to the Domain that the system belongs to, e.g. developer-tooling . There is no requirement for this Domain to be created within the same location; Existing Domains can be listed in the catalog by filtering by Kind of Domain .","title":"Systems"},{"location":"explanations/system/#systems","text":"","title":"Systems"},{"location":"explanations/system/#summary","text":"A system is a collection of resources and components . The system may expose or consume one or several APIs . It is viewed as abstraction level that provides potential consumers insights into exposed features without needing a too detailed view into the details of all components. This also gives the owning team the possibility to decide about published artifacts and APIs.","title":"Summary"},{"location":"explanations/system/#definition","text":"Backstage Docs See the backstage docs for a full description of the System entity definition. As with all other entities, a system consists of the envelope types, apiVersion and kind , as well as generic metadata and a specific spec .","title":"Definition"},{"location":"explanations/system/#apiversion-required","text":"The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal.","title":"apiVersion [Required]"},{"location":"explanations/system/#kind-required","text":"The kind is the high level entity type being described. For a software system this must be System , e.g. kind: System . Other available kind s are enumerated in the entity types reference .","title":"kind [Required]"},{"location":"explanations/system/#metadata-required","text":"A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure.","title":"metadata [Required]"},{"location":"explanations/system/#name-required","text":"The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.]","title":"name [Required]"},{"location":"explanations/system/#title-optional","text":"A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title.","title":"title [Optional]"},{"location":"explanations/system/#description-optional","text":"A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere.","title":"description [Optional]"},{"location":"explanations/system/#labels-optional","text":"Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above.","title":"labels [Optional]"},{"location":"explanations/system/#annotations-optional","text":"An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings.","title":"annotations [Optional]"},{"location":"explanations/system/#tags-optional","text":"A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total.","title":"tags [Optional]"},{"location":"explanations/system/#links-optional","text":"A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are:","title":"links [Optional]"},{"location":"explanations/system/#url-required","text":"A url in a standard uri format, e.g. url: https://example.com/some/page","title":"url [Required]"},{"location":"explanations/system/#title-optioanl","text":"A user friendly display name for the link, e.g. title: Example Website","title":"title [Optioanl]"},{"location":"explanations/system/#icon-optional","text":"A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved.","title":"icon [Optional]"},{"location":"explanations/system/#spec-required","text":"The actual specification data that describes the entity.","title":"spec [Required]"},{"location":"explanations/system/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"explanations/system/#domain-optional","text":"An entity reference to the Domain that the system belongs to, e.g. developer-tooling . There is no requirement for this Domain to be created within the same location; Existing Domains can be listed in the catalog by filtering by Kind of Domain .","title":"domain [Optional]"},{"location":"explanations/template/","text":"Templates \u00b6 Work is still ongoing in setting up templating capabilities. Please see the backstage templating docs for a description of what's to come.","title":"Templates"},{"location":"explanations/template/#templates","text":"Work is still ongoing in setting up templating capabilities. Please see the backstage templating docs for a description of what's to come.","title":"Templates"},{"location":"explanations/user/","text":"Users \u00b6 A user describes a person, such as an employee, a contractor, or similar. Users belong to Group entities in the catalog. User entities should not be defined by developer portal users, instead they will be automatically ingressed from one of the entity ingress locations.","title":"Users"},{"location":"explanations/user/#users","text":"A user describes a person, such as an employee, a contractor, or similar. Users belong to Group entities in the catalog. User entities should not be defined by developer portal users, instead they will be automatically ingressed from one of the entity ingress locations.","title":"Users"},{"location":"explanations/which-docs/","text":"Catalog Docs Options \u00b6 Summary \u00b6 This explanation will detail the trade-offs between including a site via techdocs and via linkdocs. The table below gives a brief visual summary of the points discussed: Option Techdocs Linkdocs Site Generator Mkdocs Any Inclusion Method DOM Mount IFrame Search Indexing Provides Hosting Techdocs \u00b6 Info See how to publish a techdocs site for a run through on getting started with techdocs. The techdocs plugin integrates the generated site directly into the developer portal. This allows for a much more seamless experience but requires that the site is genertated using the Mkdocs static site generator using a specific set of configuration options. Linkdocs \u00b6 Info See how to embed a linkdocs site for a run through of getting started with linkdocs. The linkdocs plugin directly embeds the hosted page into the one displayed by the developer portal. This allows greater flexibility as any externally hosted can be included, allowing use of numerous tools to build the docs site. The comprimise of this is that search indexing is not available and the docs must be externally hosted.","title":"Catalog Docs Options"},{"location":"explanations/which-docs/#catalog-docs-options","text":"","title":"Catalog Docs Options"},{"location":"explanations/which-docs/#summary","text":"This explanation will detail the trade-offs between including a site via techdocs and via linkdocs. The table below gives a brief visual summary of the points discussed: Option Techdocs Linkdocs Site Generator Mkdocs Any Inclusion Method DOM Mount IFrame Search Indexing Provides Hosting","title":"Summary"},{"location":"explanations/which-docs/#techdocs","text":"Info See how to publish a techdocs site for a run through on getting started with techdocs. The techdocs plugin integrates the generated site directly into the developer portal. This allows for a much more seamless experience but requires that the site is genertated using the Mkdocs static site generator using a specific set of configuration options.","title":"Techdocs"},{"location":"explanations/which-docs/#linkdocs","text":"Info See how to embed a linkdocs site for a run through of getting started with linkdocs. The linkdocs plugin directly embeds the hosted page into the one displayed by the developer portal. This allows greater flexibility as any externally hosted can be included, allowing use of numerous tools to build the docs site. The comprimise of this is that search indexing is not available and the docs must be externally hosted.","title":"Linkdocs"},{"location":"how-tos/debug-entity-descriptors/","text":"Debug Entity Descriptors \u00b6 Whilst the catalog is configured in read-only mode, the Create Component tools can be useful in helping you quickly draft entity descriptors or to debug ones which are not working. To debug an existing entity descriptor, simply navigate to the Register an Existing Component screen by following Catalog > Create > \"Register Existing Component\". Once on this screen you may enter the fully qualified URL (e.g. https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info.yaml ) to a misbehaving entity descriptor, and press Analyze . If an error exists with the entity descriptor it will be displayed at this point.","title":"Debug Entity Descriptors"},{"location":"how-tos/debug-entity-descriptors/#debug-entity-descriptors","text":"Whilst the catalog is configured in read-only mode, the Create Component tools can be useful in helping you quickly draft entity descriptors or to debug ones which are not working. To debug an existing entity descriptor, simply navigate to the Register an Existing Component screen by following Catalog > Create > \"Register Existing Component\". Once on this screen you may enter the fully qualified URL (e.g. https://github.com/DiamondLightSource/developer-portal/blob/main/catalog-info.yaml ) to a misbehaving entity descriptor, and press Analyze . If an error exists with the entity descriptor it will be displayed at this point.","title":"Debug Entity Descriptors"},{"location":"how-tos/embed-a-linkdocs-site/","text":"Embed a Linkdocs Site \u00b6 Preface \u00b6 This how-to will take you through the steps of embedding a documentation site in the developer portal catalog with use of the linkdocs plugin for backstage. This how-to guide assumes you have: A hosted docs site - available to the same set of users as the developer portal. An entity descriptor - which is indexed by the developer portal. Hint See how to register a component for a run down of how to create your entity descriptor and have the catalog index it Add annotation \u00b6 In order to make an embedded version of your docs site available on the developer portal, we must provide the diamond.ac.uk/viewdocs-url annotation. This annotation should point to the URL at which the docs are hosted. Example apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-backend annotations : diamond.ac.uk/viewdocs-url : https://diamondlightsource.github.io/developer-portal/ spec : owner : user:enu43627","title":"Embed a Linkdocs Site"},{"location":"how-tos/embed-a-linkdocs-site/#embed-a-linkdocs-site","text":"","title":"Embed a Linkdocs Site"},{"location":"how-tos/embed-a-linkdocs-site/#preface","text":"This how-to will take you through the steps of embedding a documentation site in the developer portal catalog with use of the linkdocs plugin for backstage. This how-to guide assumes you have: A hosted docs site - available to the same set of users as the developer portal. An entity descriptor - which is indexed by the developer portal. Hint See how to register a component for a run down of how to create your entity descriptor and have the catalog index it","title":"Preface"},{"location":"how-tos/embed-a-linkdocs-site/#add-annotation","text":"In order to make an embedded version of your docs site available on the developer portal, we must provide the diamond.ac.uk/viewdocs-url annotation. This annotation should point to the URL at which the docs are hosted. Example apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-backend annotations : diamond.ac.uk/viewdocs-url : https://diamondlightsource.github.io/developer-portal/ spec : owner : user:enu43627","title":"Add annotation"},{"location":"how-tos/link-to-remote-entities/","text":"Link to Remote Entities \u00b6 Preface \u00b6 This how-to will take you through the steps of registering multiple entities in the catalogue, where the entitiy descriptors are remotely located. Get a Repository \u00b6 To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml Create Referenced Descriptors \u00b6 It is necessary to create a number of regular entities (e.g. Components or APIs ) before we can register them together. This may be performed as explained in Register a Component or Register a Static API . Instead of their usual locations, these files should be given names and located in directories appropriate to the entity they register. For example, the entity descriptor for my-component may be located at my-component/catalog-info.yaml or catalog-info/my-component.yaml . Create an Entity Descriptor \u00b6 Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository. To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Location . E.g.: Entity Definition \u00b6 Example apiVersion : backstage.io/v1alpha1 kind : Location Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal title : Developer Portal description : The diamond developer portal. Location Spec \u00b6 Finally, we will fill out the spec . Only the targets field is required with numerous other optional fields available. Complete field descriptions are available in the Location spec reference . Important The location type is intentionally left blank such that the discovery process is inherited from whichever discovery process indexed this location. Example spec : targets : - ./catalog-info/system.yaml - ./catalog-info/frontend.yaml - ./catalog-info/backend.yaml - ./catalog-info/backend-rest.yaml Example Completed Descriptor apiVersion : backstage.io/v1alpha1 kind : Location metadata : name : developer-portal description : A RESTful API exposed by the developer portal backend. spec : targets : - ./catalog-info/system.yaml - ./catalog-info/frontend.yaml - ./catalog-info/backend.yaml - ./catalog-info/backend-rest.yaml Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Link to Remote Entities"},{"location":"how-tos/link-to-remote-entities/#link-to-remote-entities","text":"","title":"Link to Remote Entities"},{"location":"how-tos/link-to-remote-entities/#preface","text":"This how-to will take you through the steps of registering multiple entities in the catalogue, where the entitiy descriptors are remotely located.","title":"Preface"},{"location":"how-tos/link-to-remote-entities/#get-a-repository","text":"To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml","title":"Get a Repository"},{"location":"how-tos/link-to-remote-entities/#create-referenced-descriptors","text":"It is necessary to create a number of regular entities (e.g. Components or APIs ) before we can register them together. This may be performed as explained in Register a Component or Register a Static API . Instead of their usual locations, these files should be given names and located in directories appropriate to the entity they register. For example, the entity descriptor for my-component may be located at my-component/catalog-info.yaml or catalog-info/my-component.yaml .","title":"Create Referenced Descriptors"},{"location":"how-tos/link-to-remote-entities/#create-an-entity-descriptor","text":"Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository. To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Location . E.g.:","title":"Create an Entity Descriptor"},{"location":"how-tos/link-to-remote-entities/#entity-definition","text":"Example apiVersion : backstage.io/v1alpha1 kind : Location","title":"Entity Definition"},{"location":"how-tos/link-to-remote-entities/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal title : Developer Portal description : The diamond developer portal.","title":"Metadata"},{"location":"how-tos/link-to-remote-entities/#location-spec","text":"Finally, we will fill out the spec . Only the targets field is required with numerous other optional fields available. Complete field descriptions are available in the Location spec reference . Important The location type is intentionally left blank such that the discovery process is inherited from whichever discovery process indexed this location. Example spec : targets : - ./catalog-info/system.yaml - ./catalog-info/frontend.yaml - ./catalog-info/backend.yaml - ./catalog-info/backend-rest.yaml Example Completed Descriptor apiVersion : backstage.io/v1alpha1 kind : Location metadata : name : developer-portal description : A RESTful API exposed by the developer portal backend. spec : targets : - ./catalog-info/system.yaml - ./catalog-info/frontend.yaml - ./catalog-info/backend.yaml - ./catalog-info/backend-rest.yaml","title":"Location Spec"},{"location":"how-tos/link-to-remote-entities/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"how-tos/publish-a-techdocs-site/","text":"Publish a Techdocs Site \u00b6 Preface \u00b6 This how-to will take you through the steps of building and publishing a techdocs site for inclusion in the developer portal catalog. In order to do this we must build the site and push it to a S3 compatible object store. Setup & Configure Mkdocs \u00b6 To begin, follow the getting started guide for Mkdocs. You should include techdocs-core in plugins list and subsequently mkdocs-techdocs-core in your python requirements definition. Warning Beware, techdocs-core overrides various mkdocs configuration options including theme . Example site_name : Developer Portal site_url : https://0.0.0.0/ repo_url : https://github.com/DiamondLightSource/developer-portal edit_uri : edit/main/docs/ plugins : - techdocs-core Build Docs \u00b6 We will use the Techdocs command line interface node package to build our docs site locally. To do this we will run: npx @techdocs/cli generate --no-docker At this point you should see a site directory, the contents of which can be viewed in your browser. Publish Docs \u00b6 We will use the Techdocs command line interface node package to publish our docs site to the S3 bucket. In order to do this we will require the necessary credentials for the bucket. The necessary credentials should be made available as the environment variables AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY . These credentials are made available in GitHub Workflows in the DiamondLightSource organisation as TECHDOCS_S3_ACCESS_KEY_ID and TECHDOCS_S3_SECRET_ACCESS_KEY respectively or can be attained by contacting the owner of developer-portal-techdocs-bucket . Further to this, the AWS_REGION environment variable should be set to a valid region code, e.g. eu-west-2 . We will now run: npx @techdocs/cli publish --entity <NAMESPACE/KIND/NAME> --publisher-type awsS3 --storage-name techdocs --awsEndpoint https://s3.echo.stfc.ac.uk --awsS3ForcePathStyle Example GitHub Workflow name : Docs CI on : push : - main jobs : publish_techdocs : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 - name : Setup python uses : actions/setup-python@v4 with : python-version : 3.11 - name : Install docs dependencies run : pip install -r docs-requirements.txt - name : Set node uses : actions/setup-node@v3 with : node-version : 18.x - name : Generate docs run : npx @techdocs/cli generate --no-docker - name : Publish docs to s3 bucket run : > npx @techdocs/cli publish --entity default/component/developer-portal-backend --publisher-type awsS3 --storage-name techdocs --awsEndpoint https://s3.echo.stfc.ac.uk --awsS3ForcePathStyle env : AWS_ACCESS_KEY_ID : ${{ secrets.TECHDOCS_S3_ACCESS_KEY_ID }} AWS_SECRET_ACCESS_KEY : ${{ secrets.TECHDOCS_S3_SECRET_ACCESS_KEY }} AWS_REGION : \"eu-west-2\" Example GitLab Workflow image : node:18-bullseye variables : GIT_SUBMODULE_STRATEGY : recursive stages : - publish_techdocs before_script : - apt-get update - apt-get install -y --no-install-recommends python3-pip - pip install -r requirements.txt publish_techdocs : stage : publish_techdocs rules : - if : $CI_COMMIT_REF_NAME == \"main\" tags : - argus script : - npx @techdocs/cli generate --no-docker - > npx @techdocs/cli publish --entity default/component/developer-guide --publisher-type awsS3 --storage-name techdocs --awsEndpoint https://s3.echo.stfc.ac.uk --awsS3ForcePathStyle variables : AWS_REGION : \"eu-west-2\" Annotate Entity \u00b6 Finally, we will add the backstage.io/techdocs-ref annotation to the metadata.annotations field of the entity descriptor. This should point to the root directory of the documentation (i.e. the directory containing the mkdocs.yaml file). Example Entity Descriptor apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-guide annotations : backstage.io/techdocs-ref : dir:. spec : type : website lifecycle : experimental owner : user:enu43627","title":"Publish a Techdocs Site"},{"location":"how-tos/publish-a-techdocs-site/#publish-a-techdocs-site","text":"","title":"Publish a Techdocs Site"},{"location":"how-tos/publish-a-techdocs-site/#preface","text":"This how-to will take you through the steps of building and publishing a techdocs site for inclusion in the developer portal catalog. In order to do this we must build the site and push it to a S3 compatible object store.","title":"Preface"},{"location":"how-tos/publish-a-techdocs-site/#setup-configure-mkdocs","text":"To begin, follow the getting started guide for Mkdocs. You should include techdocs-core in plugins list and subsequently mkdocs-techdocs-core in your python requirements definition. Warning Beware, techdocs-core overrides various mkdocs configuration options including theme . Example site_name : Developer Portal site_url : https://0.0.0.0/ repo_url : https://github.com/DiamondLightSource/developer-portal edit_uri : edit/main/docs/ plugins : - techdocs-core","title":"Setup &amp; Configure Mkdocs"},{"location":"how-tos/publish-a-techdocs-site/#build-docs","text":"We will use the Techdocs command line interface node package to build our docs site locally. To do this we will run: npx @techdocs/cli generate --no-docker At this point you should see a site directory, the contents of which can be viewed in your browser.","title":"Build Docs"},{"location":"how-tos/publish-a-techdocs-site/#publish-docs","text":"We will use the Techdocs command line interface node package to publish our docs site to the S3 bucket. In order to do this we will require the necessary credentials for the bucket. The necessary credentials should be made available as the environment variables AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY . These credentials are made available in GitHub Workflows in the DiamondLightSource organisation as TECHDOCS_S3_ACCESS_KEY_ID and TECHDOCS_S3_SECRET_ACCESS_KEY respectively or can be attained by contacting the owner of developer-portal-techdocs-bucket . Further to this, the AWS_REGION environment variable should be set to a valid region code, e.g. eu-west-2 . We will now run: npx @techdocs/cli publish --entity <NAMESPACE/KIND/NAME> --publisher-type awsS3 --storage-name techdocs --awsEndpoint https://s3.echo.stfc.ac.uk --awsS3ForcePathStyle Example GitHub Workflow name : Docs CI on : push : - main jobs : publish_techdocs : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 - name : Setup python uses : actions/setup-python@v4 with : python-version : 3.11 - name : Install docs dependencies run : pip install -r docs-requirements.txt - name : Set node uses : actions/setup-node@v3 with : node-version : 18.x - name : Generate docs run : npx @techdocs/cli generate --no-docker - name : Publish docs to s3 bucket run : > npx @techdocs/cli publish --entity default/component/developer-portal-backend --publisher-type awsS3 --storage-name techdocs --awsEndpoint https://s3.echo.stfc.ac.uk --awsS3ForcePathStyle env : AWS_ACCESS_KEY_ID : ${{ secrets.TECHDOCS_S3_ACCESS_KEY_ID }} AWS_SECRET_ACCESS_KEY : ${{ secrets.TECHDOCS_S3_SECRET_ACCESS_KEY }} AWS_REGION : \"eu-west-2\" Example GitLab Workflow image : node:18-bullseye variables : GIT_SUBMODULE_STRATEGY : recursive stages : - publish_techdocs before_script : - apt-get update - apt-get install -y --no-install-recommends python3-pip - pip install -r requirements.txt publish_techdocs : stage : publish_techdocs rules : - if : $CI_COMMIT_REF_NAME == \"main\" tags : - argus script : - npx @techdocs/cli generate --no-docker - > npx @techdocs/cli publish --entity default/component/developer-guide --publisher-type awsS3 --storage-name techdocs --awsEndpoint https://s3.echo.stfc.ac.uk --awsS3ForcePathStyle variables : AWS_REGION : \"eu-west-2\"","title":"Publish Docs"},{"location":"how-tos/publish-a-techdocs-site/#annotate-entity","text":"Finally, we will add the backstage.io/techdocs-ref annotation to the metadata.annotations field of the entity descriptor. This should point to the root directory of the documentation (i.e. the directory containing the mkdocs.yaml file). Example Entity Descriptor apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-guide annotations : backstage.io/techdocs-ref : dir:. spec : type : website lifecycle : experimental owner : user:enu43627","title":"Annotate Entity"},{"location":"how-tos/register-a-component/","text":"Register a Component \u00b6 Preface \u00b6 This how-to will take you through the steps of registering a Component with the developer portal using one of the Git discovery locations . Get a Repository \u00b6 To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml Create an Entity Descriptor \u00b6 Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository. Entity Definition \u00b6 To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Component . Example apiVersion : backstage.io/v1alpha1 kind : Component Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal-backend title : Developer Portal Backend description : A node application performing discovery and providing the developer portal REST API. Component Spec \u00b6 Finally, we will fill out the spec . Only the type field is required with numerous other optional fields available. It is recommended that you enter a lifecycle and an owner . Complete field descriptions are available in the Component spec reference . Example spec : type : service lifecycle : experimental owner : user:enu43627 Example Complete Descriptor apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-backend title : Developer Portal Backend description : A node application performing discovery and providing the developer portal REST API. spec : type : website lifecycle : experimental system : developer-portal owner : user:enu43627 dependsOn : - component:developer-guide providesApis : - developer-portal-backend-rest Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Register a Component"},{"location":"how-tos/register-a-component/#register-a-component","text":"","title":"Register a Component"},{"location":"how-tos/register-a-component/#preface","text":"This how-to will take you through the steps of registering a Component with the developer portal using one of the Git discovery locations .","title":"Preface"},{"location":"how-tos/register-a-component/#get-a-repository","text":"To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml","title":"Get a Repository"},{"location":"how-tos/register-a-component/#create-an-entity-descriptor","text":"Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository.","title":"Create an Entity Descriptor"},{"location":"how-tos/register-a-component/#entity-definition","text":"To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Component . Example apiVersion : backstage.io/v1alpha1 kind : Component","title":"Entity Definition"},{"location":"how-tos/register-a-component/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal-backend title : Developer Portal Backend description : A node application performing discovery and providing the developer portal REST API.","title":"Metadata"},{"location":"how-tos/register-a-component/#component-spec","text":"Finally, we will fill out the spec . Only the type field is required with numerous other optional fields available. It is recommended that you enter a lifecycle and an owner . Complete field descriptions are available in the Component spec reference . Example spec : type : service lifecycle : experimental owner : user:enu43627 Example Complete Descriptor apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-backend title : Developer Portal Backend description : A node application performing discovery and providing the developer portal REST API. spec : type : website lifecycle : experimental system : developer-portal owner : user:enu43627 dependsOn : - component:developer-guide providesApis : - developer-portal-backend-rest","title":"Component Spec"},{"location":"how-tos/register-a-component/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"how-tos/register-a-group/","text":"Register a Group \u00b6 This how-to will take you through the steps of registering a Group with the developer portal. Groups are registed via a central GitLab repository . The instructions provided in the README.md file of this repository should be followed to perform group registration.","title":"Register a Group"},{"location":"how-tos/register-a-group/#register-a-group","text":"This how-to will take you through the steps of registering a Group with the developer portal. Groups are registed via a central GitLab repository . The instructions provided in the README.md file of this repository should be followed to perform group registration.","title":"Register a Group"},{"location":"how-tos/register-a-resource/","text":"Register a Resource \u00b6 Preface \u00b6 This how-to will take you through the steps of registering a Resource with the developer portal using one of the Git discovery locations . Get a Repository \u00b6 To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml Create an Entity Descriptor \u00b6 Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository. Entity Definition \u00b6 To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Resource . Example apiVersion : backstage.io/v1alpha1 kind : Resource Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal-make-believe-database title : Developer Portal Make Believe Database description : A database that I just made up to use as an example, it probably contains things. Resource Spec \u00b6 Finally, we will fill out the spec . The type and owner fields are required with numerous other optional fields available. Complete field descriptions are available in the Resource spec reference . Example spec : type : database owner : user:enu43627 Example Complete Descriptor apiVersion : backstage.io/v1alpha1 kind : Resource metadata : name : developer-portal-make-believe-database title : Developer Portal Make Believe Database description : A database that I just made up to use as an example, it probably contains things. spec : type : database system : developer-portal owner : user:enu43627 Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Register a Resource"},{"location":"how-tos/register-a-resource/#register-a-resource","text":"","title":"Register a Resource"},{"location":"how-tos/register-a-resource/#preface","text":"This how-to will take you through the steps of registering a Resource with the developer portal using one of the Git discovery locations .","title":"Preface"},{"location":"how-tos/register-a-resource/#get-a-repository","text":"To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml","title":"Get a Repository"},{"location":"how-tos/register-a-resource/#create-an-entity-descriptor","text":"Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository.","title":"Create an Entity Descriptor"},{"location":"how-tos/register-a-resource/#entity-definition","text":"To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as Resource . Example apiVersion : backstage.io/v1alpha1 kind : Resource","title":"Entity Definition"},{"location":"how-tos/register-a-resource/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal-make-believe-database title : Developer Portal Make Believe Database description : A database that I just made up to use as an example, it probably contains things.","title":"Metadata"},{"location":"how-tos/register-a-resource/#resource-spec","text":"Finally, we will fill out the spec . The type and owner fields are required with numerous other optional fields available. Complete field descriptions are available in the Resource spec reference . Example spec : type : database owner : user:enu43627 Example Complete Descriptor apiVersion : backstage.io/v1alpha1 kind : Resource metadata : name : developer-portal-make-believe-database title : Developer Portal Make Believe Database description : A database that I just made up to use as an example, it probably contains things. spec : type : database system : developer-portal owner : user:enu43627","title":"Resource Spec"},{"location":"how-tos/register-a-resource/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"how-tos/register-a-static-api/","text":"Register a Static API \u00b6 Preface \u00b6 This how-to will take you through the steps of registering an API with the developer portal using one of the Git discovery locations . Get a Repository \u00b6 To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml Create an Entity Descriptor \u00b6 Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository. Entity Definition \u00b6 To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as API . Example apiVersion : backstage.io/v1alpha1 kind : API Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal-backend-rest title : Developer Portal Backend REST API description : A RESTful API exposed by the developer portal backend. API Spec \u00b6 Finally, we will fill out the API spec . A type , a lifecycle , an owner and a definition with the system field remaining optional. Complete field descriptions are available in the API spec reference . Example spec : type : service lifecycle : experimental owner : user:enu43627 definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Schema Generation It may often be more convenient to link to a generated schema, this can be achieved with use of the $text substituion which points to the URL of a schema definiton. For example, a url of the form https://github.com/DiamondLightSource/<your_repo>/releases/latest/download/<your_schema_file> can be used to load the contents of the <your_schema> artifact from the latest GitHub release. Example Completed Descriptor apiVersion : backstage.io/v1alpha1 kind : API metadata : name : developer-portal-backend-rest description : A RESTful API exposed by the developer portal backend. spec : type : openapi lifecycle : experimental owner : user:enu43627 system : developer-portal definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Register a Static API"},{"location":"how-tos/register-a-static-api/#register-a-static-api","text":"","title":"Register a Static API"},{"location":"how-tos/register-a-static-api/#preface","text":"This how-to will take you through the steps of registering an API with the developer portal using one of the Git discovery locations .","title":"Preface"},{"location":"how-tos/register-a-static-api/#get-a-repository","text":"To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml","title":"Get a Repository"},{"location":"how-tos/register-a-static-api/#create-an-entity-descriptor","text":"Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository.","title":"Create an Entity Descriptor"},{"location":"how-tos/register-a-static-api/#entity-definition","text":"To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as API . Example apiVersion : backstage.io/v1alpha1 kind : API","title":"Entity Definition"},{"location":"how-tos/register-a-static-api/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal-backend-rest title : Developer Portal Backend REST API description : A RESTful API exposed by the developer portal backend.","title":"Metadata"},{"location":"how-tos/register-a-static-api/#api-spec","text":"Finally, we will fill out the API spec . A type , a lifecycle , an owner and a definition with the system field remaining optional. Complete field descriptions are available in the API spec reference . Example spec : type : service lifecycle : experimental owner : user:enu43627 definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Schema Generation It may often be more convenient to link to a generated schema, this can be achieved with use of the $text substituion which points to the URL of a schema definiton. For example, a url of the form https://github.com/DiamondLightSource/<your_repo>/releases/latest/download/<your_schema_file> can be used to load the contents of the <your_schema> artifact from the latest GitHub release. Example Completed Descriptor apiVersion : backstage.io/v1alpha1 kind : API metadata : name : developer-portal-backend-rest description : A RESTful API exposed by the developer portal backend. spec : type : openapi lifecycle : experimental owner : user:enu43627 system : developer-portal definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1","title":"API Spec"},{"location":"how-tos/register-a-static-api/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"how-tos/register-a-system/","text":"Register a System \u00b6 Preface \u00b6 This how-to will take you through the steps of registering a System with the developer portal using one of the Git discovery locations . Tip A lone System entity does not add significant value, therefore it is expected that other entities (e.g. Components or APIs ) will be attached to it via their spec.system field. Get a Repository \u00b6 To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml Create an Entity Descriptor \u00b6 Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository. Entity Definition \u00b6 To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as System . E.g.: Example apiVersion : backstage.io/v1alpha1 kind : System Metadata \u00b6 Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal title : Developer Portal description : The diamond developer portal. System Spec \u00b6 Finally, we will fill out the spec . There are no required fields here. However it is recommended that you enter an owner . Complete field descriptions are available in the System spec reference . Example spec : owner : user:enu43627 Example Completed Descriptor apiVersion : backstage.io/v1alpha1 kind : System metadata : name : developer-portal title : Developer Portal description : The diamond developer portal. spec : owner : user:enu43627 Push & Wait \u00b6 Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Register a System"},{"location":"how-tos/register-a-system/#register-a-system","text":"","title":"Register a System"},{"location":"how-tos/register-a-system/#preface","text":"This how-to will take you through the steps of registering a System with the developer portal using one of the Git discovery locations . Tip A lone System entity does not add significant value, therefore it is expected that other entities (e.g. Components or APIs ) will be attached to it via their spec.system field.","title":"Preface"},{"location":"how-tos/register-a-system/#get-a-repository","text":"To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml","title":"Get a Repository"},{"location":"how-tos/register-a-system/#create-an-entity-descriptor","text":"Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository.","title":"Create an Entity Descriptor"},{"location":"how-tos/register-a-system/#entity-definition","text":"To begin, we will specify the apiVersion to be backstage.io/v1alpha1 and the kind as System . E.g.: Example apiVersion : backstage.io/v1alpha1 kind : System","title":"Entity Definition"},{"location":"how-tos/register-a-system/#metadata","text":"Next, we will fill out the metadata , this is common to all entity types. Only the name field is required with numerous other optional fields available. It is recommended that you enter a title and a description . Complete field descriptions are available in the metadata reference . Example metadata : name : developer-portal title : Developer Portal description : The diamond developer portal.","title":"Metadata"},{"location":"how-tos/register-a-system/#system-spec","text":"Finally, we will fill out the spec . There are no required fields here. However it is recommended that you enter an owner . Complete field descriptions are available in the System spec reference . Example spec : owner : user:enu43627 Example Completed Descriptor apiVersion : backstage.io/v1alpha1 kind : System metadata : name : developer-portal title : Developer Portal description : The diamond developer portal. spec : owner : user:enu43627","title":"System Spec"},{"location":"how-tos/register-a-system/#push-wait","text":"Now we have created our entity decriptor in the form of a catalog-info.yaml we can push it to one of the discovery locations and wait for the developer portal to discover it - be aware that this may take a while depending on the schedule of the discovery provider.","title":"Push &amp; Wait"},{"location":"how-tos/register-multiple-entities/","text":"Register Multiple Entities \u00b6 Preface \u00b6 This how-to will take you through the steps of registering multiple entities in the catalogue from a single repository. Get a Repository \u00b6 To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml Create an Entity Descriptor \u00b6 Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository. Entity Definitions \u00b6 We can now create numerous entity descriptors seperated by --- . These will be read independantly, as if they were their own entity-descriptor files. Example apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-backend spec : type : service --- apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-frontend spec : type : website","title":"Register Multiple Entities"},{"location":"how-tos/register-multiple-entities/#register-multiple-entities","text":"","title":"Register Multiple Entities"},{"location":"how-tos/register-multiple-entities/#preface","text":"This how-to will take you through the steps of registering multiple entities in the catalogue from a single repository.","title":"Preface"},{"location":"how-tos/register-multiple-entities/#get-a-repository","text":"To begin, you will need to create or clone a repository in or from one of the Git discovery locations, such that they are available to entity ingress . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml","title":"Get a Repository"},{"location":"how-tos/register-multiple-entities/#create-an-entity-descriptor","text":"Firstly, we must create the entity descriptor file, please reference the Discovery Locations above for the appropriate location - this is typically catalog-info.yaml at the root of the repository.","title":"Create an Entity Descriptor"},{"location":"how-tos/register-multiple-entities/#entity-definitions","text":"We can now create numerous entity descriptors seperated by --- . These will be read independantly, as if they were their own entity-descriptor files. Example apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-backend spec : type : service --- apiVersion : backstage.io/v1alpha1 kind : Component metadata : name : developer-portal-frontend spec : type : website","title":"Entity Definitions"},{"location":"references/api-spec/","text":"API Spec \u00b6 type [Required] \u00b6 The type of API as a string, e.g. type: openapi . Whilst the spec.type of a API may be any string, visualisation is only available for a small subset. Further to this, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an API one of the following is used in this field: openapi - an API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec asyncapi - an API definition based on the AsyncAPI spec graphql - an API definition based on GraphQL schemas for consuming GraphQL based APIs grpc - an API definition based on Protocol Buffers to use with gRPC lifecycle [Required] \u00b6 The lifecycle state of the API as a string, e.g. lifecycle: production . Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner. system [Optional] \u00b6 An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System . definition [Required] \u00b6 The definition of the API, as a multi-line string, based on the format defined by type . For example, where type is openapi : definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Tip The API schema can be located in another file and imported by using substitutions, e.g.: definition : $text : ./schema-file.json $text , $json & $yaml are available, for more details see the backstage docs","title":"API Spec"},{"location":"references/api-spec/#api-spec","text":"","title":"API Spec"},{"location":"references/api-spec/#type-required","text":"The type of API as a string, e.g. type: openapi . Whilst the spec.type of a API may be any string, visualisation is only available for a small subset. Further to this, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an API one of the following is used in this field: openapi - an API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec asyncapi - an API definition based on the AsyncAPI spec graphql - an API definition based on GraphQL schemas for consuming GraphQL based APIs grpc - an API definition based on Protocol Buffers to use with gRPC","title":"type [Required]"},{"location":"references/api-spec/#lifecycle-required","text":"The lifecycle state of the API as a string, e.g. lifecycle: production . Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time","title":"lifecycle [Required]"},{"location":"references/api-spec/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"references/api-spec/#system-optional","text":"An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System .","title":"system [Optional]"},{"location":"references/api-spec/#definition-required","text":"The definition of the API, as a multi-line string, based on the format defined by type . For example, where type is openapi : definition : | openapi: 3.0.0 info: title: Backstage API version: 0.0.1 Tip The API schema can be located in another file and imported by using substitutions, e.g.: definition : $text : ./schema-file.json $text , $json & $yaml are available, for more details see the backstage docs","title":"definition [Required]"},{"location":"references/common-api-types/","text":"Common API Types \u00b6 Whilst the spec.type of a API may be any string, visualisation is only available for a small subset. Further to this, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an API one of the following is used in this field: openapi - an API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec asyncapi - an API definition based on the AsyncAPI spec graphql - an API definition based on GraphQL schemas for consuming GraphQL based APIs grpc - an API definition based on Protocol Buffers to use with gRPC These are selected such that they overlap with the common API types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common API Types"},{"location":"references/common-api-types/#common-api-types","text":"Whilst the spec.type of a API may be any string, visualisation is only available for a small subset. Further to this, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an API one of the following is used in this field: openapi - an API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec asyncapi - an API definition based on the AsyncAPI spec graphql - an API definition based on GraphQL schemas for consuming GraphQL based APIs grpc - an API definition based on Protocol Buffers to use with gRPC These are selected such that they overlap with the common API types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common API Types"},{"location":"references/common-component-types/","text":"Common Component Types \u00b6 Whilst the type of a Component may be any string, it is strongly recommended that you use one of the common values. Futher to this, tools including Backstage itself may read this field and behave differently depending on its value. For example, a website type component may present tooling in the Backstage interface that is specific to just websites. Thus we recommend that when specifying a component one of the following is used in this field: library - a software library service - a backend service, typically exposing an API user-interface - a local user interface website - a web user interface These are selected such that they overlap with the common component types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common Component Types"},{"location":"references/common-component-types/#common-component-types","text":"Whilst the type of a Component may be any string, it is strongly recommended that you use one of the common values. Futher to this, tools including Backstage itself may read this field and behave differently depending on its value. For example, a website type component may present tooling in the Backstage interface that is specific to just websites. Thus we recommend that when specifying a component one of the following is used in this field: library - a software library service - a backend service, typically exposing an API user-interface - a local user interface website - a web user interface These are selected such that they overlap with the common component types described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common Component Types"},{"location":"references/common-lifecycle-stages/","text":"Common Lifecycle Stages \u00b6 Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time These are selected such that they overlap with the common lifecycle stages described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common Lifecycle Stages"},{"location":"references/common-lifecycle-stages/#common-lifecycle-stages","text":"Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time These are selected such that they overlap with the common lifecycle stages described in the backstage documentation , but should be added to and ammended to reflect usage.","title":"Common Lifecycle Stages"},{"location":"references/component-spec/","text":"Component Spec \u00b6 type [Required] \u00b6 The type of Component as a string, e.g. type: service . Whilst the type of a Component may be any string, it is strongly recommended that you use one of the common values. Futher to this, tools including Backstage itself may read this field and behave differently depending on its value. For example, a website type component may present tooling in the Backstage interface that is specific to just websites. Thus we recommend that when specifying a component one of the following is used in this field: library - a software library service - a backend service, typically exposing an API user-interface - a local user interface website - a web user interface lifecycle [Required] \u00b6 The lifecycle state of the Component as a string, e.g. lifecycle: production . Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner. system [Optional] \u00b6 An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System . subcomponentOf [Optional] \u00b6 An entity reference to another Component of which this Component is part of, e.g. subComponentOf: developer-portal-frontend . There is no requirement for this Component to be created within the same location; Existing Components can be listed in the catalog by filtering by Kind of Component . providesApis [Optional] \u00b6 An array of entity references to the APIs that are provided by the Component, e.g. providesApis: [developer-portal-backend-rest] . There is no requirement for these APIs to be created within the same location; Existing APIs can be listed in the catalog by filtering by Kind of API . consumesApis [Optional] \u00b6 An array of entity references to the APIs that are consumed by the Component, e.g. consumesApis: [developer-portal-backend-rest] . There is no requirement for these APIs to be created within the same location; Existing APIs can be listed in the catalog by filtering by Kind of API . dependsOn [Optional] \u00b6 An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog.","title":"Component Spec"},{"location":"references/component-spec/#component-spec","text":"","title":"Component Spec"},{"location":"references/component-spec/#type-required","text":"The type of Component as a string, e.g. type: service . Whilst the type of a Component may be any string, it is strongly recommended that you use one of the common values. Futher to this, tools including Backstage itself may read this field and behave differently depending on its value. For example, a website type component may present tooling in the Backstage interface that is specific to just websites. Thus we recommend that when specifying a component one of the following is used in this field: library - a software library service - a backend service, typically exposing an API user-interface - a local user interface website - a web user interface","title":"type [Required]"},{"location":"references/component-spec/#lifecycle-required","text":"The lifecycle state of the Component as a string, e.g. lifecycle: production . Whilst the spec.type of a Component or API may be any string, understanding is made easier by sticking to a small set of well-known and common values. Thus we recommend that when specifying an entity one of the following is used in this field: experimental - an experiment or early, non-production entity, signaling that users may not prefer to consume it over other more established entities, or that there are low or no reliability guarantees production - an established, owned, maintained entity deprecated - an entity that is at the end of its lifecycle, and may disappear at a later point in time","title":"lifecycle [Required]"},{"location":"references/component-spec/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"references/component-spec/#system-optional","text":"An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System .","title":"system [Optional]"},{"location":"references/component-spec/#subcomponentof-optional","text":"An entity reference to another Component of which this Component is part of, e.g. subComponentOf: developer-portal-frontend . There is no requirement for this Component to be created within the same location; Existing Components can be listed in the catalog by filtering by Kind of Component .","title":"subcomponentOf [Optional]"},{"location":"references/component-spec/#providesapis-optional","text":"An array of entity references to the APIs that are provided by the Component, e.g. providesApis: [developer-portal-backend-rest] . There is no requirement for these APIs to be created within the same location; Existing APIs can be listed in the catalog by filtering by Kind of API .","title":"providesApis [Optional]"},{"location":"references/component-spec/#consumesapis-optional","text":"An array of entity references to the APIs that are consumed by the Component, e.g. consumesApis: [developer-portal-backend-rest] . There is no requirement for these APIs to be created within the same location; Existing APIs can be listed in the catalog by filtering by Kind of API .","title":"consumesApis [Optional]"},{"location":"references/component-spec/#dependson-optional","text":"An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog.","title":"dependsOn [Optional]"},{"location":"references/discovery-locations/","text":"Discovery Locations \u00b6 The developer portal is configured to search a number of locations for entity descriptors (commonly a catalog-info.yaml file). These locations include, by type: Git: github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml LDAP: ralfed.cclrc.ac.uk Users Miscellaneous: gitlab.diamond.ac.uk/sscc-docs/groups Groups These locations are defined in the catalog.providers section of the backstage configuration file backstage/app-config.yaml ( on main ).","title":"Discovery Locations"},{"location":"references/discovery-locations/#discovery-locations","text":"The developer portal is configured to search a number of locations for entity descriptors (commonly a catalog-info.yaml file). These locations include, by type: Git: github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml LDAP: ralfed.cclrc.ac.uk Users Miscellaneous: gitlab.diamond.ac.uk/sscc-docs/groups Groups These locations are defined in the catalog.providers section of the backstage configuration file backstage/app-config.yaml ( on main ).","title":"Discovery Locations"},{"location":"references/domain-spec/","text":"Domain Spec \u00b6 owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"Domain Spec"},{"location":"references/domain-spec/#domain-spec","text":"","title":"Domain Spec"},{"location":"references/domain-spec/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"references/entity-envelope/","text":"Entity Envelope \u00b6 The root fields apiVersion , kind , metadata , and spec are part of the envelope, defining the overall structure of all kind s of entity. Likewise, some metadata fields like name , labels , and annotations are of special significance and have reserved purposes and distinct shapes. apiVersion [Required] \u00b6 The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal. kind [Required] \u00b6 The kind is the high level entity type being described. The available kind s are enumerated in the entity types reference . metadata [Required] \u00b6 A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure. spec [Required] \u00b6 The actual specification data that describes the entity. The precise structure of the spec depends on the apiVersion and kind combination, and some kind s may not even have a spec at all. See individual entity references for the specification structure of specific kind s.","title":"Entity Envelope"},{"location":"references/entity-envelope/#entity-envelope","text":"The root fields apiVersion , kind , metadata , and spec are part of the envelope, defining the overall structure of all kind s of entity. Likewise, some metadata fields like name , labels , and annotations are of special significance and have reserved purposes and distinct shapes.","title":"Entity Envelope"},{"location":"references/entity-envelope/#apiversion-required","text":"The apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format and to distinguish them from other types of object that share the same type of structure - e.g. Kubernetes object manifests. At present all entity descriptors should be given an apiVersion of backstage.io/v1alpha1 . This will change as backstage develops or if we choose to add custom entity kind s to the portal.","title":"apiVersion [Required]"},{"location":"references/entity-envelope/#kind-required","text":"The kind is the high level entity type being described. The available kind s are enumerated in the entity types reference .","title":"kind [Required]"},{"location":"references/entity-envelope/#metadata-required","text":"A structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See the entity metadata reference for more details about this structure.","title":"metadata [Required]"},{"location":"references/entity-envelope/#spec-required","text":"The actual specification data that describes the entity. The precise structure of the spec depends on the apiVersion and kind combination, and some kind s may not even have a spec at all. See individual entity references for the specification structure of specific kind s.","title":"spec [Required]"},{"location":"references/entity-metadata/","text":"Entity Metadata \u00b6 The metadata root field has a number of reserved fields with specific meaning, described below. In addition to these, you may add any number of other fields directly under metadata, but be aware that general plugins and tools may not be able to understand their semantics. See Extending the model for more information. name [Required] \u00b6 The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] title [Optional] \u00b6 A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title. description [Optional] \u00b6 A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere. labels [Optional] \u00b6 Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above. annotations [Optional] \u00b6 An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings. tags [Optional] \u00b6 A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total. links [Optional] \u00b6 A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are: url [Required] \u00b6 A url in a standard uri format, e.g. url: https://example.com/some/page title [Optioanl] \u00b6 A user friendly display name for the link, e.g. title: Example Website icon [Optional] \u00b6 A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved.","title":"Entity Metadata"},{"location":"references/entity-metadata/#entity-metadata","text":"The metadata root field has a number of reserved fields with specific meaning, described below. In addition to these, you may add any number of other fields directly under metadata, but be aware that general plugins and tools may not be able to understand their semantics. See Extending the model for more information.","title":"Entity Metadata"},{"location":"references/entity-metadata/#name-required","text":"The name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity, e.g. visits-tracking-service Names must be unique per kind, at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry. Names are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The required format is as follows: Strings of length at least 1, and at most 63 Must consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.]","title":"name [Required]"},{"location":"references/entity-metadata/#title-optional","text":"A display name of the entity, to be presented in user interfaces instead of the name property above, when available. This field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title. Note that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title.","title":"title [Optional]"},{"location":"references/entity-metadata/#description-optional","text":"A human readable description of the entity, to be shown in the developer portal. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere.","title":"description [Optional]"},{"location":"references/entity-metadata/#labels-optional","text":"Labels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels . Their main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values are strings that follow the same restrictions as name above.","title":"labels [Optional]"},{"location":"references/entity-metadata/#annotations-optional","text":"An object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations . Their purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time. Both the key and the value are strings, subject to the following restrictions. Keys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.] , at most 63 characters in total. The backstage.io/ prefix is reserved for use by Backstage core components. Values can be of any length, but are limited to being strings.","title":"annotations [Optional]"},{"location":"references/entity-metadata/#tags-optional","text":"A list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs. The values are user defined, for example the programming language used for the component, like java or go. This field is optional, and currently has no special semantics. Each tag must be sequences of [a-z0-9] separated by - , at most 63 characters in total.","title":"tags [Optional]"},{"location":"references/entity-metadata/#links-optional","text":"A list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of the developer portal itself. For example, an admin dashboard or external CMS page. Users may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case. Fields of a link are:","title":"links [Optional]"},{"location":"references/entity-metadata/#url-required","text":"A url in a standard uri format, e.g. url: https://example.com/some/page","title":"url [Required]"},{"location":"references/entity-metadata/#title-optioanl","text":"A user friendly display name for the link, e.g. title: Example Website","title":"title [Optioanl]"},{"location":"references/entity-metadata/#icon-optional","text":"A key representing a visual icon to be displayed in the UI, e.g. icon: docs The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z] , possibly separated by one of [-_.] . The default backstage icon-component mappings are used, see the app-defaults for details. A generic fallback icon would be provided if a mapping cannot be resolved.","title":"icon [Optional]"},{"location":"references/entity-types/","text":"Entity Types \u00b6 The catalogue is configured to ingress the nine entity types described in Backstage Architectural Decision Record 005 (ADR005) , these are: Component Template API Group User Resource System Domain Location","title":"Entity Types"},{"location":"references/entity-types/#entity-types","text":"The catalogue is configured to ingress the nine entity types described in Backstage Architectural Decision Record 005 (ADR005) , these are: Component Template API Group User Resource System Domain Location","title":"Entity Types"},{"location":"references/location-spec/","text":"Location Spec \u00b6 type [Optional] \u00b6 The single location type, that's common to the targets specified in the spec. Typically, this should be left empty such that the location type of the target is inherited from the location type of the location entity which defines it (i.e. your defined location). Other options include url - which instructs the catalog to retrieve the descriptor from the URL; or file - which instructs the catalog to retrieve the descriptor from a local file. targets [Optional] \u00b6 A list of targets as strings. They can all be either absolute paths/URLs (depending on the type), or relative paths which are resolved relative to the location of this Location entity itself. e.g.: targets : - ./frontend/component-info.yaml - ./backend/component-info.yaml - ./backend/api-info.yaml presence [Optional] \u00b6 Describes whether the target of a location is required to exist or not. It defaults to required if not specified, can also be optional .","title":"Location Spec"},{"location":"references/location-spec/#location-spec","text":"","title":"Location Spec"},{"location":"references/location-spec/#type-optional","text":"The single location type, that's common to the targets specified in the spec. Typically, this should be left empty such that the location type of the target is inherited from the location type of the location entity which defines it (i.e. your defined location). Other options include url - which instructs the catalog to retrieve the descriptor from the URL; or file - which instructs the catalog to retrieve the descriptor from a local file.","title":"type [Optional]"},{"location":"references/location-spec/#targets-optional","text":"A list of targets as strings. They can all be either absolute paths/URLs (depending on the type), or relative paths which are resolved relative to the location of this Location entity itself. e.g.: targets : - ./frontend/component-info.yaml - ./backend/component-info.yaml - ./backend/api-info.yaml","title":"targets [Optional]"},{"location":"references/location-spec/#presence-optional","text":"Describes whether the target of a location is required to exist or not. It defaults to required if not specified, can also be optional .","title":"presence [Optional]"},{"location":"references/resource-spec/","text":"Resource Spec \u00b6 owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner. type [Required] \u00b6 The type of resource as a string, e.g. database. There is currently no enforced set of values for this field, so it is left up to the user to decide an appropriate name, in doing so the user is encouraged to reference existing Resources on the developer portal. Some common values for this field may include: database s3-bucket cluster system [Optional] \u00b6 An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System . dependsOn [Optional] \u00b6 An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog. dependencyOf [Optional] \u00b6 An array of entity references to the Components and Resources that this resource is a dependency of, e.g. dependencyOf: [artist-lookup] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog. Use of this field is discouraged in favour defining dependsOn on the dependant Component or Resource.","title":"Resource Spec"},{"location":"references/resource-spec/#resource-spec","text":"","title":"Resource Spec"},{"location":"references/resource-spec/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"references/resource-spec/#type-required","text":"The type of resource as a string, e.g. database. There is currently no enforced set of values for this field, so it is left up to the user to decide an appropriate name, in doing so the user is encouraged to reference existing Resources on the developer portal. Some common values for this field may include: database s3-bucket cluster","title":"type [Required]"},{"location":"references/resource-spec/#system-optional","text":"An entity reference to the System that the entity belongs to, e.g. developer-portal . There is no requirement for this System to be created within the same location; Existing Systems can be listed in the catalog by filtering by Kind of System .","title":"system [Optional]"},{"location":"references/resource-spec/#dependson-optional","text":"An array of entity references to the Components and Resources that this entity depends on, e.g. dependsOn: [component:developer-portal-backend] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog.","title":"dependsOn [Optional]"},{"location":"references/resource-spec/#dependencyof-optional","text":"An array of entity references to the Components and Resources that this resource is a dependency of, e.g. dependencyOf: [artist-lookup] . There is no requirement for these entities to be created within the same location; Existing entities can be listed in the catalog. Use of this field is discouraged in favour defining dependsOn on the dependant Component or Resource.","title":"dependencyOf [Optional]"},{"location":"references/supported-annotations/","text":"Supported Annotations \u00b6 The following annotations are supported for entities in the Developer Portal: github.com/project-slug - This should be set to the project slug of a component hosted on GitHub, e.g. DiamondLightSource/developer-portal , and will allow the GitHub Actions plugin to ingress the CI/CD pipeline status of your component. backstage.io/techdocs-ref - This should be set to build techdocs documentation into the \"docs\" panel of an entity. Where possible this is preffered to embedding as it allows indexing for search. See also: diamond.ac.uk/viewdocs-url diamond.ac.uk/viewdocs-url - This should be set to embed external documentation into the \"docs\" panel of an entity. See also: backstage.io/techdocs-ref","title":"Supported Annotations"},{"location":"references/supported-annotations/#supported-annotations","text":"The following annotations are supported for entities in the Developer Portal: github.com/project-slug - This should be set to the project slug of a component hosted on GitHub, e.g. DiamondLightSource/developer-portal , and will allow the GitHub Actions plugin to ingress the CI/CD pipeline status of your component. backstage.io/techdocs-ref - This should be set to build techdocs documentation into the \"docs\" panel of an entity. Where possible this is preffered to embedding as it allows indexing for search. See also: diamond.ac.uk/viewdocs-url diamond.ac.uk/viewdocs-url - This should be set to embed external documentation into the \"docs\" panel of an entity. See also: backstage.io/techdocs-ref","title":"Supported Annotations"},{"location":"references/system-spec/","text":"System Spec \u00b6 owner [Required] \u00b6 An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner. domain [Optional] \u00b6 An entity reference to the Domain that the system belongs to, e.g. developer-tooling . There is no requirement for this Domain to be created within the same location; Existing Domains can be listed in the catalog by filtering by Kind of Domain .","title":"System Spec"},{"location":"references/system-spec/#system-spec","text":"","title":"System Spec"},{"location":"references/system-spec/#owner-required","text":"An entity reference to the owner of the entity, e.g. owner: user:enu43627 . Users and Groups are automatically populated, and can listed in the catalog by filtering by Kind of User or Group respectively. The owner of an entity is the group or user that bears ultimate responsibility for the entity, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this entity belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the entity, but there will always be one ultimate owner.","title":"owner [Required]"},{"location":"references/system-spec/#domain-optional","text":"An entity reference to the Domain that the system belongs to, e.g. developer-tooling . There is no requirement for this Domain to be created within the same location; Existing Domains can be listed in the catalog by filtering by Kind of Domain .","title":"domain [Optional]"},{"location":"tutorials/web-app/","text":"Registering a Web App \u00b6 Preface \u00b6 This tutorial will take you through registration of a basic web application, producing a result like the example on the right. This app will comprise of four entities: A Component for the Backend A Component for the Frontend An API produced by the Backend and consumed by the Frontend A System which encompasses the whole app Create a Git Repository \u00b6 To begin, we will create a new git repository. To do this we will: Create a new directory with mkdir Change into this new directory with cd Intialize git with git init Let's call our web app my-web-app , thus in a new bash terminal we will execute the following: mkdir my-web-app cd my-web-app git init Create the Entity Descriptor File \u00b6 We will begin by creating the entity descriptor file, in which all of the entity definitions will be placed. This file will be indexed by the developer portal entity ingress process , thus it must be in the exact location defined for the Git discovery locations . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml touch catalog-info.yaml With our favourite text editor we will then open this file and begin filling it out. The nano editor is considered rather beginner friendly, thus we will choose to use it. You can open the file we just created by executing: nano catalog-info.yaml Create the System \u00b6 The first entity we will create is a System , this will encompass the whole app. The following contents should be entered into the catalog-info,yaml file. System Entity Definition \u00b6 Info A full description of the top level structure of an entity definition can be found in the entity envelope reference . Each entity definition must include an apiVersion and a kind . The apiVersion is used to track the version of the entity definition format that is being used, the current version is backstage.io/v1alpha1 thus we will use this. The kind is used to specify the type of entity we are defining, for a software system we use System . Thus we will begin the definition with the following: apiVersion : backstage.io/v1alpha1 kind : System System Metadata \u00b6 Info A full list of entity metadata fields can be found in the entity metadata reference . Each entity must be given some metadata, this is the same regardless of the entity kind , and will reside within the metadata object. Only a name is required, however we will choose to give the system a title and description as well. The name should be both human and machine readable, this it is required to be a globally unique string between 1 and 63 characters consisting of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] , we will choose to call our system my-web-app . The title field is less restrictive, it should simply be a short human readable string, we will title our System My Web App . The description is similar, but should be longer, we will use it to briefly describe what our system is. Thus we will add the following lines to the definition: metadata : name : my-web-app title : My Web App description : A web application created by me, consisting of a backend and frontend connected by a REST API System Spec \u00b6 Info A full list of system spec fields can be found in the system spec reference . Each entity must be given a spec, this is unique to each entity kind , and will reside within the spec object. For a System, only an owner is required, in this tutorial I will reference myself, user:enu43627 , whilst you should use your own FedID in place of mine ( enu43627 ). spec : owner : user:enu43627 Complete System Definition apiVersion : backstage.io/v1alpha1 kind : System metadata : name : my-web-app title : My Web App description : A web application created by me, consisting of a backend and frontend connected by a REST API spec : owner : user:enu43627 Create the Backend Component \u00b6 We will now create a Component for the Backend. We will append the following Component definition to the previous definition, with three dashes ( --- ) seperating them. Backend Component Entity Definition \u00b6 For a Component we must define the entity kind to be component . Thus we will begin the definition with the following: apiVersion : backstage.io/v1alpha1 kind : component Backend Component Metadata \u00b6 We will name our backend component a my-web-app-backend , give it the title My Web App Backend and an description which will briefly describe what our component does. Thus we will add the following lines to the definition: metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it provides an API with lots of useful data Backend Component Spec \u00b6 Info A full list of component spec fields can be found in the component spec reference . Each entity must be given a spec, this is unique to each entity kind , and will reside within the spec object. For a Component, a type , lifecycle , and owner are required, in addition to these we will define system and providesApis . Whilst type may be any string there are a small number of commonly used values which should be used, we will choose service to describe our Backend. The lifecycle may also be any string, but again there are a small number of commonly used values which should be used, we will choose experimental . Like with the system spec , I will reference myself, user:enu43627 as the user. The system field allows us to define the System this component belongs to, thus we will give it the same value as the metadata.name of our System. Similarly providesApis allows us to define a list of APIs which are exposed by our Backend Component, we will therefore make an entry with what will be the metadata.name of our API my-web-app-rest . Thus we will add the following lines to the definition: spec : type : service lifecycle : experimental owner : user:enu43627 system : my-web-app providesApis : - my-web-app-rest Complete Backend Component Definition apiVersion : backstage.io/v1alpha1 kind : component metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it magically works without any code spec : type : service lifecycle : experimental owner : user:enu43627 system : my-web-app providesApis : - my-web-app-rest Create the API \u00b6 We will now create an API exposed by the Backend. We will append the following API definition to the previous definition, with three dashes ( --- ) seperating them. API Entity Definition \u00b6 For an API we must define the entity kind to be API . Thus we will begin the definition with the following: apiVersion : backstage.io/v1alpha1 kind : API API Metadata \u00b6 We will name our backend API my-web-app-rest , give it the title My Web App REST API and an description which will briefly describe what our API exposes. Thus we will add the following lines to the definition: metadata : name : my-web-app-rest title : My Web App Backend description : The REST API for My Web App, it allows you to get lots of useful data API Spec \u00b6 Info A full list of API spec fields can be found in the API spec reference . Each entity must be given a spec, this is unique to each entity kind, and will reside within the spec object. For an API, a type , lifecycle , owner and definition are required, in addition to these we will define a system . Whilst type may be any string there are a small number of commonly used values which should be used, we will choose openapi as this is most appropriate for representing REST APIs. Similarly to the backend component spec we will set the lifecycle to be experimental , the owner to be myself user:enu43627 , and the system as the metadata.name of our System. The API definition should be a multi-line string in the format defined by the type , a minimal OpenAPI definition contains only a few fields and shall be used here, whilst a full definition should be used for real applications where available. Thus we will add the following lines to the definition: spec : type : openapi lifecycle : experimental owner : user:enu43627 system : my-web-app definition : | openapi: 3.0.0 info: title: My Web App REST API version: 0.0.1 Complete API Definition apiVersion : backstage.io/v1alpha1 kind : API metadata : name : my-web-app-rest title : My Web App Backend description : The REST API for My Web App, it allows you to get lots of useful data spec : type : openapi lifecycle : experimental owner : user:enu43627 system : my-web-app definition : | openapi: 3.0.0 info: title: My Web App REST API version: 0.0.1 Create the Frontend Component \u00b6 We will now create a Component for the Frontend. We will append the following Component definition to the previous definition, with three dashes ( --- ) seperating them. Frontend Component Entity Definition \u00b6 For a Component we must define the entity kind to be component . Thus we will begin the definition with the following: apiVersion : backstage.io/v1alpha1 kind : component Frontend Component Metadata \u00b6 We will name our frontend component a my-web-app-frontend , give it the title My Web App Frontend and an description which will briefly describe what our component does. Thus we will add the following lines to the definition: metadata : name : my-web-app-frontend title : My Web App Frontend description : The frontend website for My Web App, it consumes an API and displays data to users Frontend Component Spec \u00b6 Each entity must be given a spec, this is unique to each entity kind , and will reside within the spec object. For a Component, a type , lifecycle , and owner are required, in addition to these we will define system and consumesApis . Whilst type may be any string there are a small number of commonly used values which should be used, we will choose website to describe our Frontend. Similarly to the backend component spec we will set the lifecycle to be experimental , the owner to be myself user:enu43627 , and the system as the metadata.name of our System. Akin to the defining the APIs provided by the backend, we will use consumesApis to define a list of APIs which are called on by our Frontend Component, we will therefore make an entry with what will be the metadata.name of our API my-web-app-rest . Thus we will add the following lines to the definition: spec : type : website lifecycle : experimental owner : user:enu43627 system : my-web-app consumesApis : - my-web-app-rest Complete Frontend Component Definition apiVersion : backstage.io/v1alpha1 kind : component metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it magically works without any code spec : type : website lifecycle : experimental owner : user:enu43627 system : my-web-app consumesApis : - my-web-app-rest Save and exit \u00b6 Once complete we can save and exit, to do so in nano press CTRL + X to exit, Y to save and :material-keyboard-return: Return to overwrite the opened file. Complete Entity Descriptor File apiVersion : backstage.io/v1alpha1 kind : System metadata : name : my-web-app title : My Web App description : A web application created by me, consisting of a backend and frontend connected by a REST API spec : owner : user:enu43627 --- apiVersion : backstage.io/v1alpha1 kind : component metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it magically works without any code spec : type : service lifecycle : experimental owner : user:enu43627 system : my-web-app providesApis : - my-web-app-rests --- apiVersion : backstage.io/v1alpha1 kind : API metadata : name : my-web-app-rest title : My Web App Backend description : The REST API for My Web App, it allows you to get lots of useful data spec : type : openapi lifecycle : experimental owner : user:enu43627 system : my-web-app definition : | openapi: 3.0.0 info: title: My Web App REST API version: 0.0.1 --- apiVersion : backstage.io/v1alpha1 kind : component metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it magically works without any code spec : type : website lifecycle : experimental owner : user:enu43627 system : my-web-app consumesApis : - my-web-app-rest Push to a Discovery Location \u00b6 We can now push our repository to one of the discovery locations . Thus we will execute the following: git add catalog-info.yaml git commit -m \"Added developer portal catalog metadata\" git push You should now be see the componets you have registered on the developer portal - be aware that this may take a while depending on the schedule of the discovery provider. Tip If your entities do not become available after the expected duration, please see how to debug entity descriptors for information on debugging of entity descriptors.","title":"Registering a Web App"},{"location":"tutorials/web-app/#registering-a-web-app","text":"","title":"Registering a Web App"},{"location":"tutorials/web-app/#preface","text":"This tutorial will take you through registration of a basic web application, producing a result like the example on the right. This app will comprise of four entities: A Component for the Backend A Component for the Frontend An API produced by the Backend and consumed by the Frontend A System which encompasses the whole app","title":"Preface"},{"location":"tutorials/web-app/#create-a-git-repository","text":"To begin, we will create a new git repository. To do this we will: Create a new directory with mkdir Change into this new directory with cd Intialize git with git init Let's call our web app my-web-app , thus in a new bash terminal we will execute the following: mkdir my-web-app cd my-web-app git init","title":"Create a Git Repository"},{"location":"tutorials/web-app/#create-the-entity-descriptor-file","text":"We will begin by creating the entity descriptor file, in which all of the entity definitions will be placed. This file will be indexed by the developer portal entity ingress process , thus it must be in the exact location defined for the Git discovery locations . Discovery Locations github.com/DiamondLightSource Entity descriptors at /catalog-info.yaml gitlab.diamond.ac.uk Entity descriptors at /catalog-info.yaml touch catalog-info.yaml With our favourite text editor we will then open this file and begin filling it out. The nano editor is considered rather beginner friendly, thus we will choose to use it. You can open the file we just created by executing: nano catalog-info.yaml","title":"Create the Entity Descriptor File"},{"location":"tutorials/web-app/#create-the-system","text":"The first entity we will create is a System , this will encompass the whole app. The following contents should be entered into the catalog-info,yaml file.","title":"Create the System"},{"location":"tutorials/web-app/#system-entity-definition","text":"Info A full description of the top level structure of an entity definition can be found in the entity envelope reference . Each entity definition must include an apiVersion and a kind . The apiVersion is used to track the version of the entity definition format that is being used, the current version is backstage.io/v1alpha1 thus we will use this. The kind is used to specify the type of entity we are defining, for a software system we use System . Thus we will begin the definition with the following: apiVersion : backstage.io/v1alpha1 kind : System","title":"System Entity Definition"},{"location":"tutorials/web-app/#system-metadata","text":"Info A full list of entity metadata fields can be found in the entity metadata reference . Each entity must be given some metadata, this is the same regardless of the entity kind , and will reside within the metadata object. Only a name is required, however we will choose to give the system a title and description as well. The name should be both human and machine readable, this it is required to be a globally unique string between 1 and 63 characters consisting of sequences of [a-z0-9A-Z] possibly separated by one of [-_.] , we will choose to call our system my-web-app . The title field is less restrictive, it should simply be a short human readable string, we will title our System My Web App . The description is similar, but should be longer, we will use it to briefly describe what our system is. Thus we will add the following lines to the definition: metadata : name : my-web-app title : My Web App description : A web application created by me, consisting of a backend and frontend connected by a REST API","title":"System Metadata"},{"location":"tutorials/web-app/#system-spec","text":"Info A full list of system spec fields can be found in the system spec reference . Each entity must be given a spec, this is unique to each entity kind , and will reside within the spec object. For a System, only an owner is required, in this tutorial I will reference myself, user:enu43627 , whilst you should use your own FedID in place of mine ( enu43627 ). spec : owner : user:enu43627 Complete System Definition apiVersion : backstage.io/v1alpha1 kind : System metadata : name : my-web-app title : My Web App description : A web application created by me, consisting of a backend and frontend connected by a REST API spec : owner : user:enu43627","title":"System Spec"},{"location":"tutorials/web-app/#create-the-backend-component","text":"We will now create a Component for the Backend. We will append the following Component definition to the previous definition, with three dashes ( --- ) seperating them.","title":"Create the Backend Component"},{"location":"tutorials/web-app/#backend-component-entity-definition","text":"For a Component we must define the entity kind to be component . Thus we will begin the definition with the following: apiVersion : backstage.io/v1alpha1 kind : component","title":"Backend Component Entity Definition"},{"location":"tutorials/web-app/#backend-component-metadata","text":"We will name our backend component a my-web-app-backend , give it the title My Web App Backend and an description which will briefly describe what our component does. Thus we will add the following lines to the definition: metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it provides an API with lots of useful data","title":"Backend Component Metadata"},{"location":"tutorials/web-app/#backend-component-spec","text":"Info A full list of component spec fields can be found in the component spec reference . Each entity must be given a spec, this is unique to each entity kind , and will reside within the spec object. For a Component, a type , lifecycle , and owner are required, in addition to these we will define system and providesApis . Whilst type may be any string there are a small number of commonly used values which should be used, we will choose service to describe our Backend. The lifecycle may also be any string, but again there are a small number of commonly used values which should be used, we will choose experimental . Like with the system spec , I will reference myself, user:enu43627 as the user. The system field allows us to define the System this component belongs to, thus we will give it the same value as the metadata.name of our System. Similarly providesApis allows us to define a list of APIs which are exposed by our Backend Component, we will therefore make an entry with what will be the metadata.name of our API my-web-app-rest . Thus we will add the following lines to the definition: spec : type : service lifecycle : experimental owner : user:enu43627 system : my-web-app providesApis : - my-web-app-rest Complete Backend Component Definition apiVersion : backstage.io/v1alpha1 kind : component metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it magically works without any code spec : type : service lifecycle : experimental owner : user:enu43627 system : my-web-app providesApis : - my-web-app-rest","title":"Backend Component Spec"},{"location":"tutorials/web-app/#create-the-api","text":"We will now create an API exposed by the Backend. We will append the following API definition to the previous definition, with three dashes ( --- ) seperating them.","title":"Create the API"},{"location":"tutorials/web-app/#api-entity-definition","text":"For an API we must define the entity kind to be API . Thus we will begin the definition with the following: apiVersion : backstage.io/v1alpha1 kind : API","title":"API Entity Definition"},{"location":"tutorials/web-app/#api-metadata","text":"We will name our backend API my-web-app-rest , give it the title My Web App REST API and an description which will briefly describe what our API exposes. Thus we will add the following lines to the definition: metadata : name : my-web-app-rest title : My Web App Backend description : The REST API for My Web App, it allows you to get lots of useful data","title":"API Metadata"},{"location":"tutorials/web-app/#api-spec","text":"Info A full list of API spec fields can be found in the API spec reference . Each entity must be given a spec, this is unique to each entity kind, and will reside within the spec object. For an API, a type , lifecycle , owner and definition are required, in addition to these we will define a system . Whilst type may be any string there are a small number of commonly used values which should be used, we will choose openapi as this is most appropriate for representing REST APIs. Similarly to the backend component spec we will set the lifecycle to be experimental , the owner to be myself user:enu43627 , and the system as the metadata.name of our System. The API definition should be a multi-line string in the format defined by the type , a minimal OpenAPI definition contains only a few fields and shall be used here, whilst a full definition should be used for real applications where available. Thus we will add the following lines to the definition: spec : type : openapi lifecycle : experimental owner : user:enu43627 system : my-web-app definition : | openapi: 3.0.0 info: title: My Web App REST API version: 0.0.1 Complete API Definition apiVersion : backstage.io/v1alpha1 kind : API metadata : name : my-web-app-rest title : My Web App Backend description : The REST API for My Web App, it allows you to get lots of useful data spec : type : openapi lifecycle : experimental owner : user:enu43627 system : my-web-app definition : | openapi: 3.0.0 info: title: My Web App REST API version: 0.0.1","title":"API Spec"},{"location":"tutorials/web-app/#create-the-frontend-component","text":"We will now create a Component for the Frontend. We will append the following Component definition to the previous definition, with three dashes ( --- ) seperating them.","title":"Create the Frontend Component"},{"location":"tutorials/web-app/#frontend-component-entity-definition","text":"For a Component we must define the entity kind to be component . Thus we will begin the definition with the following: apiVersion : backstage.io/v1alpha1 kind : component","title":"Frontend Component Entity Definition"},{"location":"tutorials/web-app/#frontend-component-metadata","text":"We will name our frontend component a my-web-app-frontend , give it the title My Web App Frontend and an description which will briefly describe what our component does. Thus we will add the following lines to the definition: metadata : name : my-web-app-frontend title : My Web App Frontend description : The frontend website for My Web App, it consumes an API and displays data to users","title":"Frontend Component Metadata"},{"location":"tutorials/web-app/#frontend-component-spec","text":"Each entity must be given a spec, this is unique to each entity kind , and will reside within the spec object. For a Component, a type , lifecycle , and owner are required, in addition to these we will define system and consumesApis . Whilst type may be any string there are a small number of commonly used values which should be used, we will choose website to describe our Frontend. Similarly to the backend component spec we will set the lifecycle to be experimental , the owner to be myself user:enu43627 , and the system as the metadata.name of our System. Akin to the defining the APIs provided by the backend, we will use consumesApis to define a list of APIs which are called on by our Frontend Component, we will therefore make an entry with what will be the metadata.name of our API my-web-app-rest . Thus we will add the following lines to the definition: spec : type : website lifecycle : experimental owner : user:enu43627 system : my-web-app consumesApis : - my-web-app-rest Complete Frontend Component Definition apiVersion : backstage.io/v1alpha1 kind : component metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it magically works without any code spec : type : website lifecycle : experimental owner : user:enu43627 system : my-web-app consumesApis : - my-web-app-rest","title":"Frontend Component Spec"},{"location":"tutorials/web-app/#save-and-exit","text":"Once complete we can save and exit, to do so in nano press CTRL + X to exit, Y to save and :material-keyboard-return: Return to overwrite the opened file. Complete Entity Descriptor File apiVersion : backstage.io/v1alpha1 kind : System metadata : name : my-web-app title : My Web App description : A web application created by me, consisting of a backend and frontend connected by a REST API spec : owner : user:enu43627 --- apiVersion : backstage.io/v1alpha1 kind : component metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it magically works without any code spec : type : service lifecycle : experimental owner : user:enu43627 system : my-web-app providesApis : - my-web-app-rests --- apiVersion : backstage.io/v1alpha1 kind : API metadata : name : my-web-app-rest title : My Web App Backend description : The REST API for My Web App, it allows you to get lots of useful data spec : type : openapi lifecycle : experimental owner : user:enu43627 system : my-web-app definition : | openapi: 3.0.0 info: title: My Web App REST API version: 0.0.1 --- apiVersion : backstage.io/v1alpha1 kind : component metadata : name : my-web-app-backend title : My Web App Backend description : The backend service for My Web App, it magically works without any code spec : type : website lifecycle : experimental owner : user:enu43627 system : my-web-app consumesApis : - my-web-app-rest","title":"Save and exit"},{"location":"tutorials/web-app/#push-to-a-discovery-location","text":"We can now push our repository to one of the discovery locations . Thus we will execute the following: git add catalog-info.yaml git commit -m \"Added developer portal catalog metadata\" git push You should now be see the componets you have registered on the developer portal - be aware that this may take a while depending on the schedule of the discovery provider. Tip If your entities do not become available after the expected duration, please see how to debug entity descriptors for information on debugging of entity descriptors.","title":"Push to a Discovery Location"}]}